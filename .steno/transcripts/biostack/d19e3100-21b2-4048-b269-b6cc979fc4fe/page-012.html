<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Claude Code transcript - page 12</title>
    <style>
:root { --bg-color: #f5f5f5; --card-bg: #ffffff; --user-bg: #e3f2fd; --user-border: #1976d2; --assistant-bg: #f5f5f5; --assistant-border: #9e9e9e; --thinking-bg: #fff8e1; --thinking-border: #ffc107; --thinking-text: #666; --tool-bg: #f3e5f5; --tool-border: #9c27b0; --tool-result-bg: #e8f5e9; --tool-error-bg: #ffebee; --text-color: #212121; --text-muted: #757575; --code-bg: #263238; --code-text: #aed581; }
* { box-sizing: border-box; }
body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; background: var(--bg-color); color: var(--text-color); margin: 0; padding: 16px; line-height: 1.6; }
.container { max-width: 800px; margin: 0 auto; }
h1 { font-size: 1.5rem; margin-bottom: 24px; padding-bottom: 8px; border-bottom: 2px solid var(--user-border); }
.header-row { display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 12px; border-bottom: 2px solid var(--user-border); padding-bottom: 8px; margin-bottom: 24px; }
.header-row h1 { border-bottom: none; padding-bottom: 0; margin-bottom: 0; flex: 1; min-width: 200px; }
.message { margin-bottom: 16px; border-radius: 12px; overflow: hidden; box-shadow: 0 1px 3px rgba(0,0,0,0.1); }
.message.user { background: var(--user-bg); border-left: 4px solid var(--user-border); }
.message.assistant { background: var(--card-bg); border-left: 4px solid var(--assistant-border); }
.message.tool-reply { background: #fff8e1; border-left: 4px solid #ff9800; }
.tool-reply .role-label { color: #e65100; }
.tool-reply .tool-result { background: transparent; padding: 0; margin: 0; }
.tool-reply .tool-result .truncatable.truncated::after { background: linear-gradient(to bottom, transparent, #fff8e1); }
.message-header { display: flex; justify-content: space-between; align-items: center; padding: 8px 16px; background: rgba(0,0,0,0.03); font-size: 0.85rem; }
.role-label { font-weight: 600; text-transform: uppercase; letter-spacing: 0.5px; }
.user .role-label { color: var(--user-border); }
time { color: var(--text-muted); font-size: 0.8rem; }
.timestamp-link { color: inherit; text-decoration: none; }
.timestamp-link:hover { text-decoration: underline; }
.message:target { animation: highlight 2s ease-out; }
@keyframes highlight { 0% { background-color: rgba(25, 118, 210, 0.2); } 100% { background-color: transparent; } }
.message-content { padding: 16px; }
.message-content p { margin: 0 0 12px 0; }
.message-content p:last-child { margin-bottom: 0; }
.thinking { background: var(--thinking-bg); border: 1px solid var(--thinking-border); border-radius: 8px; padding: 12px; margin: 12px 0; font-size: 0.9rem; color: var(--thinking-text); }
.thinking-label { font-size: 0.75rem; font-weight: 600; text-transform: uppercase; color: #f57c00; margin-bottom: 8px; }
.thinking p { margin: 8px 0; }
.assistant-text { margin: 8px 0; }
.tool-use { background: var(--tool-bg); border: 1px solid var(--tool-border); border-radius: 8px; padding: 12px; margin: 12px 0; }
.tool-header { font-weight: 600; color: var(--tool-border); margin-bottom: 8px; display: flex; align-items: center; gap: 8px; }
.tool-icon { font-size: 1.1rem; }
.tool-description { font-size: 0.9rem; color: var(--text-muted); margin-bottom: 8px; font-style: italic; }
.tool-result { background: var(--tool-result-bg); border-radius: 8px; padding: 12px; margin: 12px 0; }
.tool-result.tool-error { background: var(--tool-error-bg); }
.file-tool { border-radius: 8px; padding: 12px; margin: 12px 0; }
.write-tool { background: linear-gradient(135deg, #e3f2fd 0%, #e8f5e9 100%); border: 1px solid #4caf50; }
.edit-tool { background: linear-gradient(135deg, #fff3e0 0%, #fce4ec 100%); border: 1px solid #ff9800; }
.file-tool-header { font-weight: 600; margin-bottom: 4px; display: flex; align-items: center; gap: 8px; font-size: 0.95rem; }
.write-header { color: #2e7d32; }
.edit-header { color: #e65100; }
.file-tool-icon { font-size: 1rem; }
.file-tool-path { font-family: monospace; background: rgba(0,0,0,0.08); padding: 2px 8px; border-radius: 4px; }
.file-tool-fullpath { font-family: monospace; font-size: 0.8rem; color: var(--text-muted); margin-bottom: 8px; word-break: break-all; }
.file-content { margin: 0; }
.edit-section { display: flex; margin: 4px 0; border-radius: 4px; overflow: hidden; }
.edit-label { padding: 8px 12px; font-weight: bold; font-family: monospace; display: flex; align-items: flex-start; }
.edit-old { background: #fce4ec; }
.edit-old .edit-label { color: #b71c1c; background: #f8bbd9; }
.edit-old .edit-content { color: #880e4f; }
.edit-new { background: #e8f5e9; }
.edit-new .edit-label { color: #1b5e20; background: #a5d6a7; }
.edit-new .edit-content { color: #1b5e20; }
.edit-content { margin: 0; flex: 1; background: transparent; font-size: 0.85rem; }
.edit-replace-all { font-size: 0.75rem; font-weight: normal; color: var(--text-muted); }
.write-tool .truncatable.truncated::after { background: linear-gradient(to bottom, transparent, #e6f4ea); }
.edit-tool .truncatable.truncated::after { background: linear-gradient(to bottom, transparent, #fff0e5); }
.todo-list { background: linear-gradient(135deg, #e8f5e9 0%, #f1f8e9 100%); border: 1px solid #81c784; border-radius: 8px; padding: 12px; margin: 12px 0; }
.todo-header { font-weight: 600; color: #2e7d32; margin-bottom: 10px; display: flex; align-items: center; gap: 8px; font-size: 0.95rem; }
.todo-items { list-style: none; margin: 0; padding: 0; }
.todo-item { display: flex; align-items: flex-start; gap: 10px; padding: 6px 0; border-bottom: 1px solid rgba(0,0,0,0.06); font-size: 0.9rem; }
.todo-item:last-child { border-bottom: none; }
.todo-icon { flex-shrink: 0; width: 20px; height: 20px; display: flex; align-items: center; justify-content: center; font-weight: bold; border-radius: 50%; }
.todo-completed .todo-icon { color: #2e7d32; background: rgba(46, 125, 50, 0.15); }
.todo-completed .todo-content { color: #558b2f; text-decoration: line-through; }
.todo-in-progress .todo-icon { color: #f57c00; background: rgba(245, 124, 0, 0.15); }
.todo-in-progress .todo-content { color: #e65100; font-weight: 500; }
.todo-pending .todo-icon { color: #757575; background: rgba(0,0,0,0.05); }
.todo-pending .todo-content { color: #616161; }
pre { background: var(--code-bg); color: var(--code-text); padding: 12px; border-radius: 6px; overflow-x: auto; font-size: 0.85rem; line-height: 1.5; margin: 8px 0; white-space: pre-wrap; word-wrap: break-word; }
pre.json { color: #e0e0e0; }
code { background: rgba(0,0,0,0.08); padding: 2px 6px; border-radius: 4px; font-size: 0.9em; }
pre code { background: none; padding: 0; }
.user-content { margin: 0; }
.truncatable { position: relative; }
.truncatable.truncated .truncatable-content { max-height: 200px; overflow: hidden; }
.truncatable.truncated::after { content: ''; position: absolute; bottom: 32px; left: 0; right: 0; height: 60px; background: linear-gradient(to bottom, transparent, var(--card-bg)); pointer-events: none; }
.message.user .truncatable.truncated::after { background: linear-gradient(to bottom, transparent, var(--user-bg)); }
.message.tool-reply .truncatable.truncated::after { background: linear-gradient(to bottom, transparent, #fff8e1); }
.tool-use .truncatable.truncated::after { background: linear-gradient(to bottom, transparent, var(--tool-bg)); }
.tool-result .truncatable.truncated::after { background: linear-gradient(to bottom, transparent, var(--tool-result-bg)); }
.expand-btn { display: none; width: 100%; padding: 8px 16px; margin-top: 4px; background: rgba(0,0,0,0.05); border: 1px solid rgba(0,0,0,0.1); border-radius: 6px; cursor: pointer; font-size: 0.85rem; color: var(--text-muted); }
.expand-btn:hover { background: rgba(0,0,0,0.1); }
.truncatable.truncated .expand-btn, .truncatable.expanded .expand-btn { display: block; }
.pagination { display: flex; justify-content: center; gap: 8px; margin: 24px 0; flex-wrap: wrap; }
.pagination a, .pagination span { padding: 5px 10px; border-radius: 6px; text-decoration: none; font-size: 0.85rem; }
.pagination a { background: var(--card-bg); color: var(--user-border); border: 1px solid var(--user-border); }
.pagination a:hover { background: var(--user-bg); }
.pagination .current { background: var(--user-border); color: white; }
.pagination .disabled { color: var(--text-muted); border: 1px solid #ddd; }
.pagination .index-link { background: var(--user-border); color: white; }
details.continuation { margin-bottom: 16px; }
details.continuation summary { cursor: pointer; padding: 12px 16px; background: var(--user-bg); border-left: 4px solid var(--user-border); border-radius: 12px; font-weight: 500; color: var(--text-muted); }
details.continuation summary:hover { background: rgba(25, 118, 210, 0.15); }
details.continuation[open] summary { border-radius: 12px 12px 0 0; margin-bottom: 0; }
.index-item { margin-bottom: 16px; border-radius: 12px; overflow: hidden; box-shadow: 0 1px 3px rgba(0,0,0,0.1); background: var(--user-bg); border-left: 4px solid var(--user-border); }
.index-item a { display: block; text-decoration: none; color: inherit; }
.index-item a:hover { background: rgba(25, 118, 210, 0.1); }
.index-item-header { display: flex; justify-content: space-between; align-items: center; padding: 8px 16px; background: rgba(0,0,0,0.03); font-size: 0.85rem; }
.index-item-number { font-weight: 600; color: var(--user-border); }
.index-item-content { padding: 16px; }
.index-item-stats { padding: 8px 16px 12px 32px; font-size: 0.85rem; color: var(--text-muted); border-top: 1px solid rgba(0,0,0,0.06); }
.index-item-commit { margin-top: 6px; padding: 4px 8px; background: #fff3e0; border-radius: 4px; font-size: 0.85rem; color: #e65100; }
.index-item-commit code { background: rgba(0,0,0,0.08); padding: 1px 4px; border-radius: 3px; font-size: 0.8rem; margin-right: 6px; }
.commit-card { margin: 8px 0; padding: 10px 14px; background: #fff3e0; border-left: 4px solid #ff9800; border-radius: 6px; }
.commit-card a { text-decoration: none; color: #5d4037; display: block; }
.commit-card a:hover { color: #e65100; }
.commit-card-hash { font-family: monospace; color: #e65100; font-weight: 600; margin-right: 8px; }
.index-commit { margin-bottom: 12px; padding: 10px 16px; background: #fff3e0; border-left: 4px solid #ff9800; border-radius: 8px; box-shadow: 0 1px 2px rgba(0,0,0,0.05); }
.index-commit a { display: block; text-decoration: none; color: inherit; }
.index-commit a:hover { background: rgba(255, 152, 0, 0.1); margin: -10px -16px; padding: 10px 16px; border-radius: 8px; }
.index-commit-header { display: flex; justify-content: space-between; align-items: center; font-size: 0.85rem; margin-bottom: 4px; }
.index-commit-hash { font-family: monospace; color: #e65100; font-weight: 600; }
.index-commit-msg { color: #5d4037; }
.index-item-long-text { margin-top: 8px; padding: 12px; background: var(--card-bg); border-radius: 8px; border-left: 3px solid var(--assistant-border); }
.index-item-long-text .truncatable.truncated::after { background: linear-gradient(to bottom, transparent, var(--card-bg)); }
.index-item-long-text-content { color: var(--text-color); }
#search-box { display: none; align-items: center; gap: 8px; }
#search-box input { padding: 6px 12px; border: 1px solid var(--assistant-border); border-radius: 6px; font-size: 16px; width: 180px; }
#search-box button, #modal-search-btn, #modal-close-btn { background: var(--user-border); color: white; border: none; border-radius: 6px; padding: 6px 10px; cursor: pointer; display: flex; align-items: center; justify-content: center; }
#search-box button:hover, #modal-search-btn:hover { background: #1565c0; }
#modal-close-btn { background: var(--text-muted); margin-left: 8px; }
#modal-close-btn:hover { background: #616161; }
#search-modal[open] { border: none; border-radius: 12px; box-shadow: 0 4px 24px rgba(0,0,0,0.2); padding: 0; width: 90vw; max-width: 900px; height: 80vh; max-height: 80vh; display: flex; flex-direction: column; }
#search-modal::backdrop { background: rgba(0,0,0,0.5); }
.search-modal-header { display: flex; align-items: center; gap: 8px; padding: 16px; border-bottom: 1px solid var(--assistant-border); background: var(--bg-color); border-radius: 12px 12px 0 0; }
.search-modal-header input { flex: 1; padding: 8px 12px; border: 1px solid var(--assistant-border); border-radius: 6px; font-size: 16px; }
#search-status { padding: 8px 16px; font-size: 0.85rem; color: var(--text-muted); border-bottom: 1px solid rgba(0,0,0,0.06); }
#search-results { flex: 1; overflow-y: auto; padding: 16px; }
.search-result { margin-bottom: 16px; border-radius: 8px; overflow: hidden; box-shadow: 0 1px 3px rgba(0,0,0,0.1); }
.search-result a { display: block; text-decoration: none; color: inherit; }
.search-result a:hover { background: rgba(25, 118, 210, 0.05); }
.search-result-page { padding: 6px 12px; background: rgba(0,0,0,0.03); font-size: 0.8rem; color: var(--text-muted); border-bottom: 1px solid rgba(0,0,0,0.06); }
.search-result-content { padding: 12px; }
.search-result mark { background: #fff59d; padding: 1px 2px; border-radius: 2px; }
@media (max-width: 600px) { body { padding: 8px; } .message, .index-item { border-radius: 8px; } .message-content, .index-item-content { padding: 12px; } pre { font-size: 0.8rem; padding: 8px; } #search-box input { width: 120px; } #search-modal[open] { width: 95vw; height: 90vh; } }
</style>
<link rel="stylesheet" href="../../steno-transcript.css">
</head>
<body>
<button class="theme-toggle" onclick="document.body.classList.toggle('dark')" style="position:fixed;top:1rem;right:1rem;z-index:1000;padding:0.5rem 1rem;border:1px solid #ddd;border-radius:0.5rem;background:#fff;cursor:pointer;font-size:0.875rem;">Toggle Dark Mode</button>
    <div class="container">
        <h1><a href="index.html" style="color: inherit; text-decoration: none;">Claude Code transcript</a> - page 12/26</h1>
        

<div class="pagination">
<a href="index.html" class="index-link">Index</a>
<a href="page-011.html">&larr; Prev</a>
<a href="page-001.html">1</a>
<a href="page-002.html">2</a>
<a href="page-003.html">3</a>
<a href="page-004.html">4</a>
<a href="page-005.html">5</a>
<a href="page-006.html">6</a>
<a href="page-007.html">7</a>
<a href="page-008.html">8</a>
<a href="page-009.html">9</a>
<a href="page-010.html">10</a>
<a href="page-011.html">11</a>
<span class="current">12</span>
<a href="page-013.html">13</a>
<a href="page-014.html">14</a>
<a href="page-015.html">15</a>
<a href="page-016.html">16</a>
<a href="page-017.html">17</a>
<a href="page-018.html">18</a>
<a href="page-019.html">19</a>
<a href="page-020.html">20</a>
<a href="page-021.html">21</a>
<a href="page-022.html">22</a>
<a href="page-023.html">23</a>
<a href="page-024.html">24</a>
<a href="page-025.html">25</a>
<a href="page-026.html">26</a>
<a href="page-013.html">Next &rarr;</a>
</div>

        
<div class="message user" id="msg-2025-12-19T21-41-36-387Z"><div class="message-header"><span class="role-label">User</span><a href="#msg-2025-12-19T21-41-36-387Z" class="timestamp-link"><time datetime="2025-12-19T21:41:36.387Z" data-timestamp="2025-12-19T21:41:36.387Z">2025-12-19T21:41:36.387Z</time></a></div><div class="message-content">
<div class="user-content"><p>can you recommend next steps</p></div></div></div>
<div class="message assistant" id="msg-2025-12-19T21-41-43-199Z"><div class="message-header"><span class="role-label">Assistant</span><a href="#msg-2025-12-19T21-41-43-199Z" class="timestamp-link"><time datetime="2025-12-19T21:41:43.199Z" data-timestamp="2025-12-19T21:41:43.199Z">2025-12-19T21:41:43.199Z</time></a></div><div class="message-content">
<div class="thinking"><div class="thinking-label">Thinking</div><p>The user is asking for recommendations on next steps. Let me review the plan file and what we've accomplished to provide good recommendations.</p>
<p>From our work:
- Completed all TOML specs (39 total)
- Completed params_schema generation from specs
- Completed SpecRegistry integration into executor/briefing/schema</p>
<p>According to the plan file, we've completed:
- Milestone 1: Macro Infrastructure
- Milestone 2: Spec Registry &amp; Validation
- Milestone 3: Auto-Provenance
- Milestone 4: Bulk Migration
- Milestone 5: Executor &amp; LLM Integration</p>
<p>Remaining:
- Milestone 6: Developer Experience (CLI tooling)</p>
<p>Let me also think about what else might be valuable beyond what's in the plan.</p></div></div></div>
<div class="message assistant" id="msg-2025-12-19T21-41-53-268Z"><div class="message-header"><span class="role-label">Assistant</span><a href="#msg-2025-12-19T21-41-53-268Z" class="timestamp-link"><time datetime="2025-12-19T21:41:53.268Z" data-timestamp="2025-12-19T21:41:53.268Z">2025-12-19T21:41:53.268Z</time></a></div><div class="message-content">
<div class="assistant-text"><p>Based on the plan and current state, here are recommended next steps:</p>
<h2>Completed (Milestones 1-5)</h2>
<ul>
<li>✅ Macro infrastructure (<code>#[bioforge_macros::primitive]</code>)</li>
<li>✅ All 39 TOML specs with full metadata</li>
<li>✅ Auto-provenance via fluent API</li>
<li>✅ Bulk migration of all primitives</li>
<li>✅ SpecRegistry integration (briefing, executor, schema)</li>
</ul>
<h2>Recommended Next Steps</h2>
<h3>Option A: Developer Experience (Milestone 6)</h3>
<p>Enhance CLI tooling for primitive development:</p>
<pre><code class="language-bash">bio primitive new indicator_species  # Generate scaffold from spec
bio primitive validate permanova     # Check impl matches spec
bio primitive test permanova         # Run bioanvil validation
</code></pre>
<p><strong>Effort</strong>: 1-2 days
<strong>Value</strong>: Faster primitive development, catch drift early</p>
<h3>Option B: Spec Validation at Startup</h3>
<p>Add runtime validation that all primitives have matching specs:
- Warn if primitive exists without spec
- Validate inputs/outputs match between spec and implementation
- Could be opt-in via <code>--validate-specs</code> flag</p>
<p><strong>Effort</strong>: Half day
<strong>Value</strong>: Catch spec drift automatically</p>
<h3>Option C: LLM Briefing Enhancement</h3>
<p>Use specs to generate richer briefing.md:
- Include <code>algorithm.formula</code> snippets for recently run primitives
- Show <code>suggested_when</code> hints for relevant primitives
- Generate workflow diagrams from <code>typical_predecessors/successors</code></p>
<p><strong>Effort</strong>: 1 day
<strong>Value</strong>: Better LLM context for analysis decisions</p>
<h3>Option D: Move to Other Priorities</h3>
<p>The spec infrastructure is solid. You could:
- Work on bioviz panel improvements
- Add new primitives (using the streamlined workflow)
- Focus on bioanvil validation coverage</p>
<p><strong>My recommendation</strong>: Option A (Developer Experience) if you plan to add more primitives, or Option D if the current primitive set is sufficient for now.</p></div></div></div>
<div class="message user" id="msg-2025-12-19T21-53-26-543Z"><div class="message-header"><span class="role-label">User</span><a href="#msg-2025-12-19T21-53-26-543Z" class="timestamp-link"><time datetime="2025-12-19T21:53:26.543Z" data-timestamp="2025-12-19T21:53:26.543Z">2025-12-19T21:53:26.543Z</time></a></div><div class="message-content">
<div class="user-content"><p>i think that most primative dev will be done by llm. is that your understanding as well?</p></div></div></div>
<div class="message assistant" id="msg-2025-12-19T21-53-37-845Z"><div class="message-header"><span class="role-label">Assistant</span><a href="#msg-2025-12-19T21-53-37-845Z" class="timestamp-link"><time datetime="2025-12-19T21:53:37.845Z" data-timestamp="2025-12-19T21:53:37.845Z">2025-12-19T21:53:37.845Z</time></a></div><div class="message-content">
<div class="thinking"><div class="thinking-label">Thinking</div><p>The user is asking whether I understand that most primitive development will be done by LLMs (like me). This is a good question about the design philosophy of biostack.</p>
<p>Looking at the architecture and the plan, I think the answer is yes - the whole spec-driven system is designed to enable LLM-driven primitive creation:</p>
<ol>
<li>The TOML specs serve as a declarative contract that an LLM can read and generate</li>
<li>The mathematical definitions in bioanvil/definitions/ are the source of truth for algorithms</li>
<li>The macro system reduces boilerplate so the LLM focuses on the algorithm</li>
<li>The provenance and session infrastructure handle context automatically</li>
<li>The LLM context fields in specs (<code>suggested_when</code>, <code>typical_predecessors/successors</code>) are explicitly designed for LLM reasoning</li>
</ol>
<p>So yes, the system is designed for LLM-driven primitive development. The user is asking if I understand this correctly.</p>
<p>Given this, Option A (Developer Experience CLI) becomes less critical - those commands are for human developers. What matters more is:
1. Clear specs that LLMs can read/write
2. Good validation so LLMs can verify their work
3. Reference data in bioanvil for testing</p>
<p>Let me confirm this understanding and suggest what might be more valuable.</p></div></div></div>
<div class="message assistant" id="msg-2025-12-19T21-53-44-628Z"><div class="message-header"><span class="role-label">Assistant</span><a href="#msg-2025-12-19T21-53-44-628Z" class="timestamp-link"><time datetime="2025-12-19T21:53:44.628Z" data-timestamp="2025-12-19T21:53:44.628Z">2025-12-19T21:53:44.628Z</time></a></div><div class="message-content">
<div class="assistant-text"><p>Yes, that's my understanding. The entire spec-driven architecture is designed for LLM primitive creation:</p>
<ol>
<li><strong>TOML specs</strong> - Declarative contracts an LLM can read/write</li>
<li><strong>bioanvil/definitions/*.md</strong> - Mathematical source of truth (not R code)</li>
<li><strong>Macro system</strong> - Minimizes boilerplate so LLM focuses on algorithm</li>
<li><strong>Provenance/session</strong> - Automatically handled by framework</li>
<li><strong>LLM context in specs</strong> - <code>suggested_when</code>, <code>typical_predecessors/successors</code> explicitly for LLM reasoning</li>
</ol>
<p>Given this, <strong>Option A (CLI tooling) is less valuable</strong> - those commands help human developers, not LLMs.</p>
<h2>More Valuable Next Steps for LLM-Driven Development</h2>
<h3>1. Validation Infrastructure</h3>
<p>When an LLM creates a primitive, it needs to verify correctness:
- Clear test patterns against bioanvil reference data
- Automated validation that can run in a single command
- Clear error messages when results don't match</p>
<h3>2. CLAUDE.md Enhancement</h3>
<p>Add a section specifically for primitive creation:
- Link to spec template
- Reference the mathematical definitions
- Show the expected workflow: spec → algorithm → validate</p>
<h3>3. Spec-to-Scaffold Generation (in-code)</h3>
<p>Rather than CLI, a function in bioforge that an LLM can reference:
- <code>PrimitiveSpec::generate_scaffold()</code> → outputs the Rust struct template
- LLM reads spec, generates algorithm, validates against bioanvil</p>
<p>Would any of these be valuable, or should we move to other priorities?</p></div></div></div>
<div class="message user" id="msg-2025-12-19T21-55-16-828Z"><div class="message-header"><span class="role-label">User</span><a href="#msg-2025-12-19T21-55-16-828Z" class="timestamp-link"><time datetime="2025-12-19T21:55:16.828Z" data-timestamp="2025-12-19T21:55:16.828Z">2025-12-19T21:55:16.828Z</time></a></div><div class="message-content">
<div class="user-content"><p>for this I worry about context bloat within the claude.md. I think it needs to be updated, but should be lean. We also had a claude agent skill that was supposed to help in this area. can you review our claude agent skill and reassess this recommendation?</p></div></div></div><details class="continuation"><summary>Session continuation summary</summary>
<div class="message user" id="msg-2025-12-19T21-55-59-954Z"><div class="message-header"><span class="role-label">User</span><a href="#msg-2025-12-19T21-55-59-954Z" class="timestamp-link"><time datetime="2025-12-19T21:55:59.954Z" data-timestamp="2025-12-19T21:55:59.954Z">2025-12-19T21:55:59.954Z</time></a></div><div class="message-content">
<div class="user-content"><p>This session is being continued from a previous conversation that ran out of context. The conversation is summarized below:
Analysis:
Let me chronologically analyze the conversation:</p>
<ol>
<li>
<p><strong>Initial Context</strong>: This is a continuation of previous work on the "Generalized Primitive Development System" for biostack. The previous session had completed TOML specs creation for Filter and was starting on Normalize specs.</p>
</li>
<li>
<p><strong>First User Message</strong>: "continue with params_schema generation from specs"</p>
</li>
<li>User wanted to continue with the next task from the todo list</li>
<li>
<p>I needed to add <code>to_params_schema()</code> method to convert TOML specs to runtime ParamsSchema</p>
</li>
<li>
<p><strong>Implementation of params_schema generation</strong>:</p>
</li>
<li>Read <code>spec.rs</code> to understand existing structure</li>
<li>Read <code>schema.rs</code> to understand ParamsSchema, ParamType, ParamValue types</li>
<li>Added <code>alias = "allowed_values"</code> to ParamSpec for TOML compatibility</li>
<li>Added <code>to_params_schema()</code> method to PrimitiveSpec</li>
<li>Added <code>to_param_type()</code> method to ParamSpec</li>
<li>Added <code>toml_to_param_value()</code> helper function</li>
<li>Added <code>params_schema()</code> method to SpecRegistry</li>
<li>
<p>Added comprehensive tests</p>
</li>
<li>
<p><strong>Second User Message</strong>: After successful tests, committed and pushed changes</p>
</li>
<li>
<p><strong>Third Integration Work</strong>: SpecRegistry into executor/briefing</p>
</li>
<li>Read briefing.rs and executor.rs - found SpecRegistry was ALREADY integrated for workflow suggestions</li>
<li>Identified the <code>bio schema</code> command as needing enhancement</li>
<li>
<p>Updated schema.rs to fall back to SpecRegistry when primitive's params_schema is empty</p>
</li>
<li>
<p><strong>Fourth User Message</strong>: "test bio schema permanova with the new integration"</p>
</li>
<li>Ran the command and confirmed it shows parameters from TOML spec</li>
<li>
<p>Tested beta_diversity (enum type) and clr (float type) to verify all param types work</p>
</li>
<li>
<p><strong>Fifth User Message</strong>: "can you recommend next steps"</p>
</li>
<li>
<p>I provided options: Developer Experience CLI, Spec Validation, LLM Briefing Enhancement, or Move to Other Priorities</p>
</li>
<li>
<p><strong>Sixth User Message</strong>: "i think that most primative dev will be done by llm. is that your understanding as well?"</p>
</li>
<li>User is questioning whether CLI tooling is valuable if LLMs will create primitives</li>
<li>I confirmed yes, the architecture is designed for LLM-driven development</li>
<li>
<p>Suggested different priorities: validation infrastructure, CLAUDE.md enhancement, spec-to-scaffold generation</p>
</li>
<li>
<p><strong>Seventh User Message</strong>: "for this I worry about context bloat within the claude.md. I think it needs to be updated, but should be lean. We also had a claude agent skill that was supposed to help in this area. can you review our claude agent skill and reassess this recommendation?"</p>
</li>
<li>User is concerned about CLAUDE.md context bloat</li>
<li>User mentions there's a "claude agent skill" that should help with primitive development</li>
<li>User wants me to review this skill and reassess recommendations</li>
<li>Then the summary request was triggered</li>
</ol>
<p>Key files modified:
- <code>bioforge/src/primitive/spec.rs</code> - Added params_schema generation
- <code>bioengine/src/commands/schema.rs</code> - Added SpecRegistry fallback</p>
<p>No errors encountered during this session.</p>
<p>The user's most recent request was to review the "claude agent skill" and reassess recommendations, but then the summary was requested. The pending task is to review that skill.</p>
<p>Summary:</p>
<h2>1. Primary Request and Intent</h2>
<p>The user requested continuation of the "Generalized Primitive Development System" plan, specifically:
1. Add <code>params_schema</code> generation from TOML specs (completed)
2. Integrate SpecRegistry into executor/briefing (completed)
3. Test the integration with <code>bio schema permanova</code> (completed)
4. Recommend next steps (provided)
5. <strong>Most recent</strong>: Review the "claude agent skill" for primitive development and reassess recommendations, with concern about CLAUDE.md context bloat</p>
<h2>2. Key Technical Concepts</h2>
<ul>
<li><strong>PrimitiveSpec</strong> - TOML specification structure for primitives</li>
<li><strong>ParamsSchema</strong> - Runtime parameter schema with ParamDef, ParamType, ParamValue</li>
<li><strong>SpecRegistry</strong> - Registry that loads and provides access to TOML specs</li>
<li><strong>Macro-based primitives</strong> - Use <code>#[bioforge_macros::primitive]</code> and return empty <code>params_schema()</code></li>
<li><strong>LLM-driven primitive development</strong> - The architecture is designed for LLMs to create primitives using specs as contracts</li>
<li><strong>Spec fields</strong>: <code>typical_predecessors</code>, <code>typical_successors</code>, <code>suggested_when</code> for LLM workflow reasoning</li>
</ul>
<h2>3. Files and Code Sections</h2>
<h3><code>bioforge/src/primitive/spec.rs</code></h3>
<p>Added params_schema generation capability:</p>
<pre><code class="language-rust">/// Generate a ParamsSchema from this spec.
pub fn to_params_schema(&amp;self) -&gt; super::ParamsSchema {
    use super::{ParamDef, ParamType, ParamValue, ParamsSchema};
    use std::borrow::Cow;

    let mut schema = ParamsSchema::new();

    for (name, param_spec) in &amp;self.params {
        let param_type = param_spec.to_param_type();
        let default = param_spec.default.as_ref().map(toml_to_param_value);
        let description = param_spec.description.clone().unwrap_or_default();

        let def = ParamDef {
            name: Cow::Owned(name.clone()),
            description: Cow::Owned(description),
            param_type,
            required: param_spec.required,
            default,
        };

        schema = schema.param(def);
    }

    schema
}
</code></pre>
<pre><code class="language-rust">impl ParamSpec {
    /// Convert this param spec to a ParamType.
    pub fn to_param_type(&amp;self) -&gt; super::ParamType {
        match self.param_type.as_str() {
            &quot;float&quot; =&gt; ParamType::Float { min: self.min, max: self.max },
            &quot;integer&quot; =&gt; ParamType::Integer {
                min: self.min.map(|v| v as i64),
                max: self.max.map(|v| v as i64),
            },
            &quot;boolean&quot; =&gt; ParamType::Boolean,
            &quot;string&quot; =&gt; {
                if let Some(values) = &amp;self.values {
                    ParamType::Enum {
                        variants: values.iter().map(|s| Cow::Owned(s.clone())).collect(),
                    }
                } else {
                    ParamType::String
                }
            }
            _ =&gt; ParamType::String,
        }
    }
}
</code></pre>
<p>Also added <code>alias = "allowed_values"</code> to ParamSpec for TOML compatibility:</p>
<pre><code class="language-rust">#[serde(default, alias = &quot;allowed_values&quot;)]
pub values: Option&lt;Vec&lt;String&gt;&gt;,
</code></pre>
<h3><code>bioengine/src/commands/schema.rs</code></h3>
<p>Updated to fall back to SpecRegistry for macro-based primitives:</p>
<pre><code class="language-rust">//! Show primitive parameter schema

use bioforge::primitive::{PrimitiveRegistry, SpecRegistry};

use crate::commands::specs_dir;
use crate::error::{BioengineError, Result};
use crate::output::{self, OutputFormat, PrimitiveSchema, SchemaField};

pub async fn run(name: &amp;str, format: OutputFormat) -&gt; Result&lt;()&gt; {
    let registry = PrimitiveRegistry::with_builtins();
    let primitive = registry.get(name)
        .ok_or_else(|| BioengineError::PrimitiveNotFound(name.to_string()))?;

    // ... inputs/outputs extraction ...

    // Get params from primitive's params_schema(), or fall back to TOML spec
    let params_schema = primitive.params_schema();
    let params_json = if params_schema.params.is_empty() {
        // Try loading from SpecRegistry
        if let Some(spec_registry) = load_spec_registry() {
            if let Some(spec_schema) = spec_registry.params_schema(name) {
                serde_json::to_value(&amp;spec_schema).unwrap_or(serde_json::Value::Null)
            } else {
                serde_json::Value::Null
            }
        } else {
            serde_json::Value::Null
        }
    } else {
        serde_json::to_value(&amp;params_schema).unwrap_or(serde_json::Value::Null)
    };

    // ... output ...
}

fn load_spec_registry() -&gt; Option&lt;SpecRegistry&gt; {
    let specs_path = specs_dir()?;
    SpecRegistry::from_directory(&amp;specs_path).ok()
}
</code></pre>
<h2>4. Errors and Fixes</h2>
<p>No errors were encountered in this session. All tests passed:
- 703 bioforge tests passed
- 91 bioengine tests passed</p>
<h2>5. Problem Solving</h2>
<ul>
<li><strong>Problem</strong>: Macro-based primitives return empty <code>params_schema()</code>, making <code>bio schema</code> useless for them</li>
<li><strong>Solution</strong>: Fall back to SpecRegistry to load params from TOML specs</li>
<li><strong>Verification</strong>: Tested with <code>bio schema permanova</code>, <code>beta_diversity</code>, <code>clr</code> - all show correct parameters including enum types with variants</li>
</ul>
<h2>6. All User Messages</h2>
<ol>
<li>"continue with params_schema generation from specs"</li>
<li>"test bio schema permanova with the new integration"</li>
<li>"can you recommend next steps"</li>
<li>"i think that most primative dev will be done by llm. is that your understanding as well?"</li>
<li>"for this I worry about context bloat within the claude.md. I think it needs to be updated, but should be lean. We also had a claude agent skill that was supposed to help in this area. can you review our claude agent skill and reassess this recommendation?"</li>
</ol>
<h2>7. Pending Tasks</h2>
<ul>
<li>Review the "claude agent skill" for primitive development</li>
<li>Reassess recommendations for next steps with consideration for:</li>
<li>LLM-driven primitive development (not human CLI tooling)</li>
<li>Avoiding CLAUDE.md context bloat</li>
<li>Leveraging existing skill infrastructure</li>
</ul>
<h2>8. Current Work</h2>
<p>The user and I were discussing next steps after completing the spec infrastructure. I recommended several options, and the user clarified that:
1. Most primitive development will be done by LLMs (not humans)
2. CLAUDE.md should stay lean to avoid context bloat
3. There's an existing "claude agent skill" that was supposed to help with primitive development</p>
<p>The user's exact request: <em>"for this I worry about context bloat within the claude.md. I think it needs to be updated, but should be lean. We also had a claude agent skill that was supposed to help in this area. can you review our claude agent skill and reassess this recommendation?"</em></p>
<h2>9. Optional Next Step</h2>
<p>Review the claude agent skill (likely in <code>.claude/</code> directory or similar) to understand what infrastructure already exists for LLM-driven primitive development, then reassess recommendations.</p>
<p>User's exact words: <em>"can you review our claude agent skill and reassess this recommendation?"</em>.
Please continue the conversation from where we left it off without asking the user any further questions. Continue with the last task that you were asked to work on.</p></div></div></div></details>
<div class="message assistant" id="msg-2025-12-19T21-56-06-237Z"><div class="message-header"><span class="role-label">Assistant</span><a href="#msg-2025-12-19T21-56-06-237Z" class="timestamp-link"><time datetime="2025-12-19T21:56:06.237Z" data-timestamp="2025-12-19T21:56:06.237Z">2025-12-19T21:56:06.237Z</time></a></div><div class="message-content">
<div class="thinking"><div class="thinking-label">Thinking</div><p>The user wants me to continue from where we left off. The last task was to review the "claude agent skill" for primitive development and reassess recommendations.</p>
<p>Let me search for the claude agent skill in the codebase. It's likely in <code>.claude/</code> directory or similar location.</p></div></div></div>
<div class="message assistant" id="msg-2025-12-19T21-56-07-406Z"><div class="message-header"><span class="role-label">Assistant</span><a href="#msg-2025-12-19T21-56-07-406Z" class="timestamp-link"><time datetime="2025-12-19T21:56:07.406Z" data-timestamp="2025-12-19T21:56:07.406Z">2025-12-19T21:56:07.406Z</time></a></div><div class="message-content">
<div class="assistant-text"><p>I'll review the claude agent skill to understand what infrastructure already exists for LLM-driven primitive development.</p></div></div></div>
<div class="message assistant" id="msg-2025-12-19T21-56-07-604Z"><div class="message-header"><span class="role-label">Assistant</span><a href="#msg-2025-12-19T21-56-07-604Z" class="timestamp-link"><time datetime="2025-12-19T21:56:07.604Z" data-timestamp="2025-12-19T21:56:07.604Z">2025-12-19T21:56:07.604Z</time></a></div><div class="message-content">
<div class="tool-use" data-tool-id="toolu_0118ELRQfNdh5wyPtaZVCoU8"><div class="tool-header"><span class="tool-icon">⚙</span> Glob</div><div class="truncatable"><div class="truncatable-content"><pre class="json">{
  &#34;pattern&#34;: &#34;**/.claude/**/*&#34;
}</pre></div><button class="expand-btn">Show more</button></div></div></div></div>
<div class="message assistant" id="msg-2025-12-19T21-56-08-148Z"><div class="message-header"><span class="role-label">Assistant</span><a href="#msg-2025-12-19T21-56-08-148Z" class="timestamp-link"><time datetime="2025-12-19T21:56:08.148Z" data-timestamp="2025-12-19T21:56:08.148Z">2025-12-19T21:56:08.148Z</time></a></div><div class="message-content">
<div class="tool-use" data-tool-id="toolu_013pEKXZPCPvjQBi1UVwVMmv"><div class="tool-header"><span class="tool-icon">⚙</span> Glob</div><div class="truncatable"><div class="truncatable-content"><pre class="json">{
  &#34;pattern&#34;: &#34;**/skills/**/*&#34;
}</pre></div><button class="expand-btn">Show more</button></div></div></div></div>
<div class="message assistant" id="msg-2025-12-19T21-56-08-567Z"><div class="message-header"><span class="role-label">Assistant</span><a href="#msg-2025-12-19T21-56-08-567Z" class="timestamp-link"><time datetime="2025-12-19T21:56:08.567Z" data-timestamp="2025-12-19T21:56:08.567Z">2025-12-19T21:56:08.567Z</time></a></div><div class="message-content">
<div class="tool-use" data-tool-id="toolu_01E8HdHvvjsymbWfGBZbds5B"><div class="tool-header"><span class="tool-icon">⚙</span> Glob</div><div class="truncatable"><div class="truncatable-content"><pre class="json">{
  &#34;pattern&#34;: &#34;**/*skill*&#34;
}</pre></div><button class="expand-btn">Show more</button></div></div></div></div>
<div class="message tool-reply" id="msg-2025-12-19T21-56-10-202Z"><div class="message-header"><span class="role-label">Tool reply</span><a href="#msg-2025-12-19T21-56-10-202Z" class="timestamp-link"><time datetime="2025-12-19T21:56:10.202Z" data-timestamp="2025-12-19T21:56:10.202Z">2025-12-19T21:56:10.202Z</time></a></div><div class="message-content"><div class="tool-result"><div class="truncatable"><div class="truncatable-content"><pre>/Users/scotthandley/Code/biostack/.claude/skills/biostack/PRIMITIVE_GENERATION.md
/Users/scotthandley/Code/biostack/.claude/skills/biostack/SKILL.md
/Users/scotthandley/Code/biostack/.claude/skills/biostack/PRIMITIVES.md
/Users/scotthandley/Code/biostack/.claude/skills/biostack/INTERPRETATION.md
/Users/scotthandley/Code/biostack/.claude/skills/biostack/STANDARD_WORKFLOWS.md</pre></div><button class="expand-btn">Show more</button></div></div></div></div>
<div class="message tool-reply" id="msg-2025-12-19T21-56-10-206Z"><div class="message-header"><span class="role-label">Tool reply</span><a href="#msg-2025-12-19T21-56-10-206Z" class="timestamp-link"><time datetime="2025-12-19T21:56:10.206Z" data-timestamp="2025-12-19T21:56:10.206Z">2025-12-19T21:56:10.206Z</time></a></div><div class="message-content"><div class="tool-result"><div class="truncatable"><div class="truncatable-content"><pre>No files found</pre></div><button class="expand-btn">Show more</button></div></div></div></div>
<div class="message tool-reply" id="msg-2025-12-19T21-56-10-206Z"><div class="message-header"><span class="role-label">Tool reply</span><a href="#msg-2025-12-19T21-56-10-206Z" class="timestamp-link"><time datetime="2025-12-19T21:56:10.206Z" data-timestamp="2025-12-19T21:56:10.206Z">2025-12-19T21:56:10.206Z</time></a></div><div class="message-content"><div class="tool-result"><div class="truncatable"><div class="truncatable-content"><pre>/Users/scotthandley/Code/biostack/.claude/skills/biostack/PRIMITIVE_GENERATION.md
/Users/scotthandley/Code/biostack/.claude/skills/biostack/SKILL.md
/Users/scotthandley/Code/biostack/.claude/skills/biostack/PRIMITIVES.md
/Users/scotthandley/Code/biostack/.claude/skills/biostack/INTERPRETATION.md
/Users/scotthandley/Code/biostack/.claude/skills/biostack/STANDARD_WORKFLOWS.md</pre></div><button class="expand-btn">Show more</button></div></div></div></div>
<div class="message assistant" id="msg-2025-12-19T21-56-14-374Z"><div class="message-header"><span class="role-label">Assistant</span><a href="#msg-2025-12-19T21-56-14-374Z" class="timestamp-link"><time datetime="2025-12-19T21:56:14.374Z" data-timestamp="2025-12-19T21:56:14.374Z">2025-12-19T21:56:14.374Z</time></a></div><div class="message-content">
<div class="thinking"><div class="thinking-label">Thinking</div><p>There's a <code>.claude/skills/biostack/</code> directory with several skill files. Let me read these to understand the existing infrastructure for LLM-driven primitive development.</p></div></div></div>
<div class="message assistant" id="msg-2025-12-19T21-56-14-960Z"><div class="message-header"><span class="role-label">Assistant</span><a href="#msg-2025-12-19T21-56-14-960Z" class="timestamp-link"><time datetime="2025-12-19T21:56:14.960Z" data-timestamp="2025-12-19T21:56:14.960Z">2025-12-19T21:56:14.960Z</time></a></div><div class="message-content">
<div class="assistant-text"><p>Found the skill files. Let me read them to understand the existing infrastructure.</p></div></div></div>
<div class="message assistant" id="msg-2025-12-19T21-56-15-712Z"><div class="message-header"><span class="role-label">Assistant</span><a href="#msg-2025-12-19T21-56-15-712Z" class="timestamp-link"><time datetime="2025-12-19T21:56:15.712Z" data-timestamp="2025-12-19T21:56:15.712Z">2025-12-19T21:56:15.712Z</time></a></div><div class="message-content">
<div class="tool-use" data-tool-id="toolu_014ML2zAPNv5qHjfBfEj8ARn"><div class="tool-header"><span class="tool-icon">⚙</span> Read</div><div class="truncatable"><div class="truncatable-content"><pre class="json">{
  &#34;file_path&#34;: &#34;/Users/scotthandley/Code/biostack/.claude/skills/biostack/SKILL.md&#34;
}</pre></div><button class="expand-btn">Show more</button></div></div></div></div>
<div class="message assistant" id="msg-2025-12-19T21-56-16-464Z"><div class="message-header"><span class="role-label">Assistant</span><a href="#msg-2025-12-19T21-56-16-464Z" class="timestamp-link"><time datetime="2025-12-19T21:56:16.464Z" data-timestamp="2025-12-19T21:56:16.464Z">2025-12-19T21:56:16.464Z</time></a></div><div class="message-content">
<div class="tool-use" data-tool-id="toolu_01J1vUQDbUCNa923ok7icwi3"><div class="tool-header"><span class="tool-icon">⚙</span> Read</div><div class="truncatable"><div class="truncatable-content"><pre class="json">{
  &#34;file_path&#34;: &#34;/Users/scotthandley/Code/biostack/.claude/skills/biostack/PRIMITIVE_GENERATION.md&#34;
}</pre></div><button class="expand-btn">Show more</button></div></div></div></div>
<div class="message assistant" id="msg-2025-12-19T21-56-17-136Z"><div class="message-header"><span class="role-label">Assistant</span><a href="#msg-2025-12-19T21-56-17-136Z" class="timestamp-link"><time datetime="2025-12-19T21:56:17.136Z" data-timestamp="2025-12-19T21:56:17.136Z">2025-12-19T21:56:17.136Z</time></a></div><div class="message-content">
<div class="tool-use" data-tool-id="toolu_01KPKX5DVtzouJzrkDfNx5Qd"><div class="tool-header"><span class="tool-icon">⚙</span> Read</div><div class="truncatable"><div class="truncatable-content"><pre class="json">{
  &#34;file_path&#34;: &#34;/Users/scotthandley/Code/biostack/.claude/skills/biostack/PRIMITIVES.md&#34;
}</pre></div><button class="expand-btn">Show more</button></div></div></div></div>
<div class="message assistant" id="msg-2025-12-19T21-56-18-254Z"><div class="message-header"><span class="role-label">Assistant</span><a href="#msg-2025-12-19T21-56-18-254Z" class="timestamp-link"><time datetime="2025-12-19T21:56:18.254Z" data-timestamp="2025-12-19T21:56:18.254Z">2025-12-19T21:56:18.254Z</time></a></div><div class="message-content">
<div class="tool-use" data-tool-id="toolu_01Sy5ARnA4XJCgjMDSidkzXf"><div class="tool-header"><span class="tool-icon">⚙</span> Read</div><div class="truncatable"><div class="truncatable-content"><pre class="json">{
  &#34;file_path&#34;: &#34;/Users/scotthandley/Code/biostack/.claude/skills/biostack/INTERPRETATION.md&#34;
}</pre></div><button class="expand-btn">Show more</button></div></div></div></div>
<div class="message assistant" id="msg-2025-12-19T21-56-19-128Z"><div class="message-header"><span class="role-label">Assistant</span><a href="#msg-2025-12-19T21-56-19-128Z" class="timestamp-link"><time datetime="2025-12-19T21:56:19.128Z" data-timestamp="2025-12-19T21:56:19.128Z">2025-12-19T21:56:19.128Z</time></a></div><div class="message-content">
<div class="tool-use" data-tool-id="toolu_01PYJ2whj6xQZQDDjE3KLNXz"><div class="tool-header"><span class="tool-icon">⚙</span> Read</div><div class="truncatable"><div class="truncatable-content"><pre class="json">{
  &#34;file_path&#34;: &#34;/Users/scotthandley/Code/biostack/.claude/skills/biostack/STANDARD_WORKFLOWS.md&#34;
}</pre></div><button class="expand-btn">Show more</button></div></div></div></div>
<div class="message tool-reply" id="msg-2025-12-19T21-56-19-192Z"><div class="message-header"><span class="role-label">Tool reply</span><a href="#msg-2025-12-19T21-56-19-192Z" class="timestamp-link"><time datetime="2025-12-19T21:56:19.192Z" data-timestamp="2025-12-19T21:56:19.192Z">2025-12-19T21:56:19.192Z</time></a></div><div class="message-content"><div class="tool-result"><div class="truncatable"><div class="truncatable-content"><pre>     1→---
     2→name: biostack
     3→description: Execute bioinformatics analyses using BioStack primitives. Use when user has count matrices, microbiome data, or RNA-seq data and wants normalization, differential analysis, diversity metrics, or statistical testing.
     4→---
     5→
     6→# BioStack Analysis Skill
     7→
     8→BioStack is an LLM-native bioinformatics platform. You compose statistical analyses from primitives based on data characteristics, not fixed pipelines.
     9→
    10→## Two Modes of Operation
    11→
    12→### 1. Data-Driven Composition (Default)
    13→Let `diagnose` analyze the data and recommend methods:
    14→```
    15→diagnose → recommendations → select primitives → execute
    16→```
    17→This adapts to the specific data structure (sparsity, overdispersion, sample size).
    18→
    19→### 2. Standard Workflows (User-Requested)
    20→When user explicitly asks for &quot;DESeq2 workflow&quot; or &quot;vegan-style analysis&quot;, use established patterns. See [STANDARD_WORKFLOWS.md](STANDARD_WORKFLOWS.md).
    21→
    22→## Quick Start
    23→
    24→### 1. Read Session Context First
    25→```
    26→.biostack/briefing.md    ← Current session state, data summary, analysis phase
    27→.biostack/context.md     ← Updated after each operation
    28→```
    29→**Always read briefing.md before taking action.** It contains:
    30→- Data sources and shapes
    31→- Recent operations
    32→- Current analysis phase
    33→- Suggested next steps (auto-generated)
    34→
    35→### 2. Initialize If Needed
    36→```bash
    37→bio init      # Creates .biostack/ directory
    38→bio start     # Launches daemon
    39→```
    40→
    41→### 3. Execute Primitives
    42→Write YAML to `.biostack/commands/pending/`:
    43→```yaml
    44→primitive: diagnose
    45→inputs:
    46→  counts: counts.csv
    47→```
    48→Daemon executes automatically. Results appear in `.biostack/results/`.
    49→
    50→**Automatic Feedback:** After writing a command file, you&#x27;ll receive automatic feedback like:
    51→```
    52→✓ PERMANOVA: F=2.7672, p=0.004 (SIGNIFICANT) (1ms)
    53→```
    54→Report this result to the user with interpretation.
    55→
    56→### 4. Read and Interpret Results
    57→Results are JSON in `.biostack/results/`. Interpret for the user - don&#x27;t just report numbers.
    58→
    59→**After each command execution:**
    60→1. Note the automatic feedback (✓ or ✗)
    61→2. For significant results, explain the meaning
    62→3. For non-significant results, explain limitations (sample size, effect size)
    63→4. Suggest logical next steps based on the outcome
    64→
    65→## Data-Driven Composition Flow
    66→
    67→### Step 1: Always Start with Diagnose
    68→```yaml
    69→primitive: diagnose
    70→inputs:
    71→  counts: counts.csv
    72→```
    73→
    74→### Step 2: Read Recommendations
    75→The `diagnose` output contains:
    76→```json
    77→{
    78→  &quot;recommendations&quot;: {
    79→    &quot;normalization&quot;: &quot;MedianOfRatios&quot;,    // → use median_of_ratios primitive
    80→    &quot;variance_model&quot;: &quot;NegativeBinomial&quot;, // → use fit_glm with family: negative_binomial
    81→    &quot;inference&quot;: &quot;Wald&quot;,                  // → use wald primitive
    82→    &quot;correction&quot;: &quot;BenjaminiHochberg&quot;,    // → use benjamini_hochberg primitive
    83→    &quot;use_compositional&quot;: false,           // → skip CLR transform
    84→    &quot;confidence&quot;: 0.8,                    // → how confident the recommendation is
    85→    &quot;rationale&quot;: [...]                    // → why these methods were chosen
    86→  }
    87→}
    88→```
    89→
    90→### Step 3: Compose from Recommendations
    91→Map recommendations to primitives:
    92→
    93→| Recommendation | Primitive |
    94→|---------------|-----------|
    95→| normalization: MedianOfRatios | `median_of_ratios` |
    96→| normalization: TMM | `tmm` |
    97→| normalization: UpperQuartile | `upper_quartile` |
    98→| inference: Wald | `wald` |
    99→| inference: LRT | `lrt` |
   100→| inference: Permutation | `permutation` |
   101→| correction: BenjaminiHochberg | `benjamini_hochberg` |
   102→| correction: Bonferroni | `bonferroni` |
   103→| use_compositional: true | Apply `clr` transform first |
   104→
   105→### Step 4: Execute Sequence
   106→Based on recommendations, execute primitives in order:
   107→1. Filter (if needed based on sparsity)
   108→2. Normalize (as recommended)
   109→3. Transform (if compositional)
   110→4. Model (fit_glm)
   111→5. Test (as recommended)
   112→6. Correct (as recommended)
   113→
   114→## Session Structure
   115→
   116→```
   117→.biostack/
   118→├── briefing.md          # READ THIS FIRST - session context
   119→├── context.md           # Updated after each operation
   120→├── data/                # Input data files
   121→│   ├── counts.csv
   122→│   └── groups.txt
   123→├── commands/
   124→│   └── pending/         # Write YAML commands here
   125→├── results/             # JSON results appear here
   126→└── session.db           # Session graph (bioledger)
   127→```
   128→
   129→## Data Format
   130→
   131→**Count Matrix** (`counts.csv`):
   132→```csv
   133→feature,sample1,sample2,sample3,sample4
   134→gene1,100,120,80,95
   135→gene2,50,60,45,55
   136→```
   137→
   138→**Sample Groups** (`groups.txt`):
   139→```
   140→control
   141→control
   142→treatment
   143→treatment
   144→```
   145→
   146→## Available Primitives
   147→
   148→See [PRIMITIVES.md](PRIMITIVES.md) for complete reference.
   149→
   150→| Category | Primitives |
   151→|----------|------------|
   152→| Diagnose | `diagnose` |
   153→| Filter | `filter_prevalence`, `filter_abundance`, `filter_variance` |
   154→| Normalize | `tmm`, `median_of_ratios`, `upper_quartile` |
   155→| Transform | `clr`, `vst`, `rlog`, `log`, `zscore` |
   156→| Models | `fit_glm` |
   157→| Tests | `wald`, `lrt`, `score`, `permutation`, `bootstrap`, `permanova`, `anosim`, `mrpp`, `indicator_species`, `simper` |
   158→| Correct | `benjamini_hochberg`, `bonferroni`, `holm`, `qvalue`, `local_fdr` |
   159→| Diversity | `alpha_diversity`, `beta_diversity` |
   160→| Ordination | `pca`, `pcoa`, `nmds` |
   161→
   162→## Interpreting Results
   163→
   164→See [INTERPRETATION.md](INTERPRETATION.md) for guidance on explaining statistical outputs to users.
   165→
   166→## Standard Workflows
   167→
   168→When user explicitly requests a standard workflow (e.g., &quot;run DESeq2&quot;, &quot;do vegan analysis&quot;), see [STANDARD_WORKFLOWS.md](STANDARD_WORKFLOWS.md).
   169→
   170→## CLI Commands
   171→
   172→```bash
   173→bio init              # Initialize session
   174→bio start             # Start daemon
   175→bio stop              # Stop daemon
   176→bio status            # Check health
   177→bio primitives        # List all primitives
   178→bio schema &lt;name&gt;     # Show primitive schema
   179→```
   180→
   181→## Key Principles
   182→
   183→1. **Read briefing.md first** - it tells you the current state
   184→2. **Let diagnose drive** - don&#x27;t assume methods, let data characteristics decide
   185→3. **Explain findings** - interpret statistics, don&#x27;t just report numbers
   186→4. **Session context updates** - context.md refreshes after each operation
   187→

&lt;system-reminder&gt;
Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
&lt;/system-reminder&gt;
</pre></div><button class="expand-btn">Show more</button></div></div></div></div>
<div class="message tool-reply" id="msg-2025-12-19T21-56-19-192Z"><div class="message-header"><span class="role-label">Tool reply</span><a href="#msg-2025-12-19T21-56-19-192Z" class="timestamp-link"><time datetime="2025-12-19T21:56:19.192Z" data-timestamp="2025-12-19T21:56:19.192Z">2025-12-19T21:56:19.192Z</time></a></div><div class="message-content"><div class="tool-result"><div class="truncatable"><div class="truncatable-content"><pre>     1→# Auto-Generating New Primitives
     2→
     3→When a user needs an analysis that doesn&#x27;t exist as a primitive, you can create it on-the-fly. This workflow ensures new primitives are properly implemented, tested, and validated.
     4→
     5→---
     6→
     7→## When to Generate a New Primitive
     8→
     9→### Detection Triggers
    10→
    11→1. **User requests an analysis not in PRIMITIVES.md**:
    12→   - &quot;Calculate Aitchison distance&quot; (if not available)
    13→   - &quot;Run indicator species analysis&quot; (if not available)
    14→   - &quot;Perform MRPP&quot; (Multi-Response Permutation Procedure)
    15→
    16→2. **Diagnose recommends unavailable method**:
    17→   ```json
    18→   &quot;recommendations&quot;: {
    19→     &quot;additional_analyses&quot;: [&quot;indicator_species&quot;, &quot;simper&quot;]
    20→   }
    21→   ```
    22→
    23→3. **User explicitly asks for a custom primitive**:
    24→   - &quot;Can you add a primitive for...&quot;
    25→   - &quot;I need a method that...&quot;
    26→
    27→### Before Generating
    28→
    29→1. **Check if primitive exists**: `bio primitives | grep &lt;name&gt;`
    30→2. **Check spec exists**: `bio primitive list`
    31→3. **Search bioanvil definitions**: Check `bioanvil/definitions/` for existing math
    32→
    33→---
    34→
    35→## Generation Workflow
    36→
    37→### Phase 1: Specification
    38→
    39→**1.1 Write the TOML spec**
    40→
    41→```bash
    42→# Create spec file
    43→touch bioforge/specs/&lt;primitive_name&gt;.toml
    44→```
    45→
    46→Spec template:
    47→```toml
    48→[primitive]
    49→name = &quot;&lt;primitive_name&gt;&quot;
    50→category = &quot;&lt;category&gt;&quot;  # test, filter, normalize, transform, diversity, etc.
    51→description = &quot;&lt;one-line description&gt;&quot;
    52→
    53→[params.&lt;param_name&gt;]
    54→type = &quot;&lt;string|integer|float|boolean|enum&gt;&quot;
    55→required = &lt;true|false&gt;
    56→description = &quot;&lt;description&gt;&quot;
    57→# Optional: default, min, max, variants
    58→
    59→[[inputs]]
    60→slot = &quot;&lt;slot_name&gt;&quot;  # counts, metadata, distance_matrix, etc.
    61→required = true
    62→description = &quot;&lt;why needed&gt;&quot;
    63→
    64→[[outputs]]
    65→slot = &quot;&lt;slot_name&gt;&quot;
    66→description = &quot;&lt;what it contains&gt;&quot;
    67→
    68→[algorithm]
    69→formula = &quot;&quot;&quot;
    70→&lt;mathematical formula&gt;
    71→&quot;&quot;&quot;
    72→notes = &quot;&lt;implementation considerations&gt;&quot;
    73→
    74→[validation]
    75→r_package = &quot;&lt;reference R package&gt;&quot;
    76→r_function = &quot;&lt;reference function&gt;&quot;
    77→```
    78→
    79→**1.2 Validate the spec**
    80→
    81→```bash
    82→bio primitive validate &lt;primitive_name&gt;
    83→```
    84→
    85→### Phase 2: Mathematical Foundation
    86→
    87→**2.1 Write definition document**
    88→
    89→Create `bioanvil/definitions/&lt;primitive_name&gt;.md`:
    90→
    91→```markdown
    92→# &lt;Primitive Name&gt;: Mathematical Definition
    93→
    94→## Reference
    95→&lt;citation&gt;
    96→
    97→## Formula
    98→&lt;core formula with explanation&gt;
    99→
   100→## Worked Example
   101→&lt;step-by-step calculation with numbers&gt;
   102→
   103→## Properties
   104→- &lt;key property 1&gt;
   105→- &lt;key property 2&gt;
   106→
   107→## Test Values
   108→&lt;expected outputs for known inputs&gt;
   109→```
   110→
   111→**2.2 Check existing definitions**
   112→
   113→```bash
   114→ls bioanvil/definitions/
   115→# alpha_diversity.md, beta_diversity.md, statistical_tests.md, indicator_species.md
   116→```
   117→
   118→### Phase 3: Implementation
   119→
   120→**3.1 Generate scaffold**
   121→
   122→```bash
   123→bio primitive new &lt;primitive_name&gt;
   124→```
   125→
   126→This creates:
   127→- `bioforge/src/primitive/builtins/&lt;primitive_name&gt;.rs` (implementation stub)
   128→- Updates to `bioanvil/definitions/&lt;primitive_name&gt;.md` (if not exists)
   129→- `bioanvil/reference/r/&lt;primitive_name&gt;.R` (R reference script)
   130→
   131→**3.2 Implement the algorithm**
   132→
   133→Open the generated `.rs` file and replace `todo!()` with actual implementation:
   134→
   135→```rust
   136→fn execute(&amp;self, ctx: &amp;mut ExecutionContext) -&gt; Result&lt;()&gt; {
   137→    // 1. Get inputs
   138→    let counts = ctx.get::&lt;CountMatrix&gt;(DataSlot::Counts)
   139→        .ok_or_else(|| BioforgeError::MissingData(&quot;counts&quot;.to_string()))?;
   140→
   141→    // 2. Get parameters
   142→    let threshold: f64 = ctx.param_or(&quot;threshold&quot;, 0.05);
   143→
   144→    // 3. Implement algorithm
   145→    // ... your implementation here ...
   146→
   147→    // 4. Set outputs
   148→    ctx.set(DataSlot::PValues, p_values);
   149→    ctx.set(DataSlot::TestStatistics, statistics);
   150→
   151→    Ok(())
   152→}
   153→```
   154→
   155→**3.3 Register the primitive**
   156→
   157→```bash
   158→bio primitive register &lt;primitive_name&gt;
   159→```
   160→
   161→This automatically:
   162→- Adds `mod &lt;primitive_name&gt;;` to `builtins/mod.rs`
   163→- Adds `pub use &lt;primitive_name&gt;::*;` to `builtins/mod.rs`
   164→- Adds `registry.register(&lt;PrimitiveName&gt;);` to `registry.rs`
   165→
   166→### Phase 4: Testing &amp; Validation
   167→
   168→**CRITICAL**: This phase ensures user confidence. All tests must pass.
   169→
   170→**4.1 Run unit tests**
   171→
   172→```bash
   173→cargo test -p bioforge &lt;primitive_name&gt;
   174→```
   175→
   176→Expected tests:
   177→- `test_&lt;name&gt;_identity` - name, category correct
   178→- `test_&lt;name&gt;_schema` - parameters defined
   179→- `test_&lt;name&gt;_inputs_outputs` - slots defined
   180→
   181→**4.2 Run bioanvil validation**
   182→
   183→```bash
   184→bio primitive test &lt;primitive_name&gt;
   185→```
   186→
   187→This runs the primitive against bioanvil datasets and produces a validation report:
   188→
   189→```
   190→=== Validation Report: indicator_species ===
   191→
   192→Dataset: two_group_strong
   193→  Sensitivity: 0.925 (37/40 true positives detected)
   194→  Specificity: 0.983 (59/60 true negatives correct)
   195→  Precision: 0.974 (37/38 detections were correct)
   196→  F1 Score: 0.949
   197→  FALSE POSITIVE RATE: 0.017 (1/60)
   198→
   199→Dataset: null (false positive calibration)
   200→  Features detected as significant: 3/100
   201→  Expected at alpha=0.05: ~5
   202→  CALIBRATION: PASS (FPR = 0.03)
   203→
   204→Dataset: sparse
   205→  Execution: PASS (handled zeros correctly)
   206→
   207→Reference comparison (R/indicspecies):
   208→  IndVal correlation: r = 0.998
   209→  P-value correlation: r = 0.995
   210→  Max discrepancy: 0.002
   211→
   212→OVERALL: PASS (4/4 tests passed)
   213→```
   214→
   215→**4.3 Test against worked examples**
   216→
   217→Verify implementation matches the worked example in the definition:
   218→
   219→```rust
   220→#[test]
   221→fn test_against_definition_example() {
   222→    // From bioanvil/definitions/indicator_species.md
   223→    let counts = vec![
   224→        vec![100, 90, 10, 5],   // feat_1
   225→        vec![5, 8, 80, 95],     // feat_2
   226→        vec![50, 55, 45, 52],   // feat_3
   227→    ];
   228→    let groups = vec![&quot;A&quot;, &quot;A&quot;, &quot;B&quot;, &quot;B&quot;];
   229→
   230→    let result = compute_indval(&amp;counts, &amp;groups);
   231→
   232→    // Expected from definition
   233→    assert!((result[0].indval - 92.7).abs() &lt; 1.0);
   234→}
   235→```
   236→
   237→### Phase 5: Deployment
   238→
   239→**5.1 Compile and restart**
   240→
   241→```bash
   242→cargo build --release -p bioengine &amp;&amp; bio restart
   243→```
   244→
   245→**5.2 Verify availability**
   246→
   247→```bash
   248→bio schema &lt;primitive_name&gt;
   249→```
   250→
   251→**5.3 Test in session**
   252→
   253→```yaml
   254→primitive: &lt;primitive_name&gt;
   255→inputs:
   256→  counts: counts.csv
   257→  metadata: metadata.csv
   258→params:
   259→  &lt;param&gt;: &lt;value&gt;
   260→```
   261→
   262→---
   263→
   264→## Testing Requirements
   265→
   266→### Required Test Coverage
   267→
   268→| Test Type | Dataset | Purpose | Pass Criteria |
   269→|-----------|---------|---------|---------------|
   270→| **Correctness** | two_group_strong | Detect true effects | Sensitivity &gt; 0.80 |
   271→| **Specificity** | two_group_strong | Avoid false positives | FDR &lt; 0.10 |
   272→| **Calibration** | null | FPR at nominal level | FPR within 2x of alpha |
   273→| **Edge cases** | sparse | Handle zeros | No crashes, reasonable output |
   274→| **Multi-group** | multi_group | Handle &gt;2 groups | Correct for all pairs |
   275→| **Reference** | any | Match R implementation | r &gt; 0.95 for statistics |
   276→
   277→### Test Against Ground Truth
   278→
   279→Bioanvil datasets have known true effects:
   280→
   281→```rust
   282→use bioanvil::{Dataset, GroundTruth};
   283→
   284→let dataset = Dataset::load(&quot;two_group_strong&quot;)?;
   285→let truth = GroundTruth::load(&quot;two_group_strong&quot;)?;
   286→
   287→// Run your primitive
   288→let results = my_primitive(&amp;dataset);
   289→
   290→// Evaluate
   291→let significant: HashSet&lt;_&gt; = results
   292→    .iter()
   293→    .filter(|r| r.p_value &lt; 0.05)
   294→    .map(|r| r.feature_id.clone())
   295→    .collect();
   296→
   297→let metrics = truth.evaluate(&amp;significant);
   298→
   299→assert!(metrics.sensitivity &gt; 0.80, &quot;Must detect most true effects&quot;);
   300→assert!(metrics.fdr() &lt; 0.10, &quot;False discovery rate too high&quot;);
   301→```
   302→
   303→### False Positive Calibration (CRITICAL)
   304→
   305→The `null` dataset has NO true effects. Use it to verify your primitive doesn&#x27;t over-call:
   306→
   307→```rust
   308→let truth = GroundTruth::load(&quot;null&quot;)?;
   309→assert_eq!(truth.true_positives.len(), 0);  // No true effects
   310→
   311→// Run primitive at alpha = 0.05
   312→let significant = run_primitive_at_alpha(&amp;dataset, 0.05);
   313→
   314→// Should be approximately 5% false positives
   315→let fpr = significant.len() as f64 / 100.0;
   316→assert!(fpr &lt; 0.10, &quot;FPR too high: {}&quot;, fpr);
   317→```
   318→
   319→---
   320→
   321→## Documentation for User Confidence
   322→
   323→After validation passes, generate a test report that users can review.
   324→
   325→### Validation Report Template
   326→
   327→Create `bioanvil/reports/&lt;primitive_name&gt;_validation.md`:
   328→
   329→```markdown
   330→# Validation Report: &lt;primitive_name&gt;
   331→
   332→Generated: &lt;timestamp&gt;
   333→BioStack version: &lt;version&gt;
   334→
   335→## Summary
   336→
   337→| Metric | Value | Threshold | Status |
   338→|--------|-------|-----------|--------|
   339→| Sensitivity | 0.925 | &gt; 0.80 | PASS |
   340→| Specificity | 0.983 | &gt; 0.90 | PASS |
   341→| F1 Score | 0.949 | &gt; 0.85 | PASS |
   342→| FPR Calibration | 0.03 | &lt; 0.10 | PASS |
   343→| R Correlation | 0.998 | &gt; 0.95 | PASS |
   344→
   345→## Datasets Tested
   346→
   347→### two_group_strong
   348→- 100 features, 20 samples
   349→- 40 truly differential features
   350→- Result: 37/40 detected, 1 false positive
   351→
   352→### null
   353→- 100 features, 20 samples
   354→- NO true effects
   355→- Result: 3 features called (FPR = 0.03)
   356→
   357→### sparse
   358→- 100 features, 20 samples
   359→- ~67% zeros
   360→- Result: Completed without error
   361→
   362→## Reference Comparison
   363→
   364→Compared to R package `&lt;package&gt;`::&lt;function&gt;()
   365→
   366→| Statistic | Correlation | Max Difference |
   367→|-----------|-------------|----------------|
   368→| Test statistic | 0.998 | 0.15 |
   369→| P-value | 0.995 | 0.003 |
   370→
   371→## Mathematical Verification
   372→
   373→Tested against worked example from definition:
   374→- Expected IndVal: 92.7%
   375→- Computed IndVal: 92.68%
   376→- MATCH
   377→
   378→## Conclusion
   379→
   380→This primitive is validated and ready for production use.
   381→```
   382→
   383→---
   384→
   385→## Common Issues &amp; Solutions
   386→
   387→### Issue: Low Sensitivity
   388→
   389→**Symptoms**: Missing true positives
   390→**Causes**:
   391→- Threshold too stringent
   392→- Algorithm error
   393→- Wrong null hypothesis
   394→
   395→**Solution**: Check against worked example, verify formula implementation
   396→
   397→### Issue: High False Positive Rate
   398→
   399→**Symptoms**: FPR &gt;&gt; alpha on null dataset
   400→**Causes**:
   401→- P-value calculation error
   402→- Permutation insufficient
   403→- Edge case handling
   404→
   405→**Solution**: Increase permutations, check permutation procedure
   406→
   407→### Issue: Differs from R Reference
   408→
   409→**Symptoms**: Statistics don&#x27;t match R package
   410→**Causes**:
   411→- Different algorithm variant
   412→- Tie handling differs
   413→- Numerical precision
   414→
   415→**Solution**: Document the difference, verify both are mathematically correct
   416→
   417→---
   418→
   419→## Quick Reference
   420→
   421→### Commands
   422→
   423→```bash
   424→# Check existing primitives
   425→bio primitives
   426→
   427→# List available specs
   428→bio primitive list
   429→
   430→# Validate spec
   431→bio primitive validate &lt;name&gt;
   432→
   433→# Generate scaffold
   434→bio primitive new &lt;name&gt;
   435→
   436→# Register primitive
   437→bio primitive register &lt;name&gt;
   438→
   439→# Run validation tests
   440→bio primitive test &lt;name&gt;
   441→
   442→# Compile and restart
   443→cargo build --release -p bioengine &amp;&amp; bio restart
   444→
   445→# Verify working
   446→bio schema &lt;name&gt;
   447→```
   448→
   449→### File Locations
   450→
   451→| File | Purpose |
   452→|------|---------|
   453→| `bioforge/specs/&lt;name&gt;.toml` | Primitive specification |
   454→| `bioforge/src/primitive/builtins/&lt;name&gt;.rs` | Implementation |
   455→| `bioanvil/definitions/&lt;name&gt;.md` | Mathematical definition |
   456→| `bioanvil/reference/r/&lt;name&gt;.R` | R reference script |
   457→| `bioanvil/reports/&lt;name&gt;_validation.md` | Validation report |
   458→
   459→### Bioanvil Datasets
   460→
   461→| Dataset | Samples | Features | True Effects | Use Case |
   462→|---------|---------|----------|--------------|----------|
   463→| two_group_strong | 20 | 100 | 40 | Basic correctness |
   464→| multi_group | 30 | 100 | 30 | Multi-group tests |
   465→| continuous | 20 | 100 | 30 | Continuous covariates |
   466→| sparse | 20 | 100 | 30 | High sparsity |
   467→| null | 20 | 100 | 0 | FPR calibration |
   468→
   469→---
   470→
   471→## Example: Complete Workflow
   472→
   473→User asks: &quot;Can you calculate indicator species for my microbiome data?&quot;
   474→
   475→### Step 1: Check availability
   476→```bash
   477→bio primitives | grep indicator
   478→# No output - doesn&#x27;t exist
   479→```
   480→
   481→### Step 2: Create spec
   482→Write `bioforge/specs/indicator_species.toml` with parameters, inputs, outputs.
   483→
   484→### Step 3: Write definition
   485→Create `bioanvil/definitions/indicator_species.md` with IndVal formula and worked example.
   486→
   487→### Step 4: Generate and implement
   488→```bash
   489→bio primitive new indicator_species
   490→# Edit bioforge/src/primitive/builtins/indicator_species.rs
   491→```
   492→
   493→### Step 5: Register
   494→```bash
   495→bio primitive register indicator_species
   496→```
   497→
   498→### Step 6: Test
   499→```bash
   500→cargo test -p bioforge indicator_species
   501→bio primitive test indicator_species
   502→```
   503→
   504→### Step 7: Deploy
   505→```bash
   506→cargo build --release -p bioengine &amp;&amp; bio restart
   507→```
   508→
   509→### Step 8: Use
   510→```yaml
   511→primitive: indicator_species
   512→inputs:
   513→  counts: counts.csv
   514→  metadata: metadata.csv
   515→params:
   516→  grouping_column: Treatment
   517→  n_permutations: 999
   518→```
   519→
   520→This workflow ensures new primitives are properly implemented, tested, and validated before use.
   521→

&lt;system-reminder&gt;
Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
&lt;/system-reminder&gt;
</pre></div><button class="expand-btn">Show more</button></div></div></div></div>
<div class="message tool-reply" id="msg-2025-12-19T21-56-19-192Z"><div class="message-header"><span class="role-label">Tool reply</span><a href="#msg-2025-12-19T21-56-19-192Z" class="timestamp-link"><time datetime="2025-12-19T21:56:19.192Z" data-timestamp="2025-12-19T21:56:19.192Z">2025-12-19T21:56:19.192Z</time></a></div><div class="message-content"><div class="tool-result"><div class="truncatable"><div class="truncatable-content"><pre>     1→# BioStack Primitives Reference
     2→
     3→Complete reference for all available primitives. Run `biostack schema &lt;name&gt;` for the latest schema.
     4→
     5→---
     6→
     7→## Diagnose
     8→
     9→### `diagnose`
    10→
    11→Comprehensive data diagnostics with method recommendations.
    12→
    13→**Inputs:**
    14→- `counts` (required): Count matrix CSV file
    15→
    16→**Outputs:**
    17→- Data Characteristics: quality score, sparsity, overdispersion, zero-inflation assessment
    18→- Recommendations: suggested normalization, variance model, inference method
    19→
    20→**Parameters:**
    21→| Name | Type | Default | Description |
    22→|------|------|---------|-------------|
    23→| `alpha_level` | float | 0.05 | Significance level for statistical tests |
    24→| `min_prevalence` | float | 0.1 | Minimum prevalence threshold |
    25→| `high_sparsity_threshold` | float | 0.7 | Sparsity level considered high |
    26→| `library_size_cv_threshold` | float | 0.5 | CV threshold for library size concern |
    27→
    28→**Example:**
    29→```yaml
    30→primitive: diagnose
    31→inputs:
    32→  counts: counts.csv
    33→params:
    34→  alpha_level: 0.05
    35→```
    36→
    37→**Interpreting Results:**
    38→- `quality_score`: 0-1, higher is better
    39→- `sparsity.level`: Low, Moderate, High, Extreme
    40→- `overdispersion.overall`: NoOverdispersion, MildOverdispersion, StrongOverdispersion
    41→- `recommendations.normalization`: MedianOfRatios, TMM, UpperQuartile
    42→- `recommendations.inference`: Wald, LRT, Permutation
    43→
    44→---
    45→
    46→## Normalization
    47→
    48→### `tmm`
    49→
    50→TMM (Trimmed Mean of M-values) normalization from edgeR.
    51→
    52→**Inputs:**
    53→- `counts` (required): Count matrix
    54→
    55→**Outputs:**
    56→- Size Factors: per-sample normalization factors
    57→- Normalized Counts: scaled count matrix
    58→
    59→**Parameters:**
    60→| Name | Type | Default | Description |
    61→|------|------|---------|-------------|
    62→| `trim_m` | float | 0.3 | Fraction of M-values to trim (0-0.5) |
    63→| `trim_a` | float | 0.05 | Fraction of A-values to trim (0-0.5) |
    64→
    65→**Example:**
    66→```yaml
    67→primitive: tmm
    68→inputs:
    69→  counts: counts.csv
    70→params:
    71→  trim_m: 0.3
    72→  trim_a: 0.05
    73→```
    74→
    75→### `median_of_ratios`
    76→
    77→DESeq2-style size factor estimation via median ratio to geometric mean.
    78→
    79→**Inputs:**
    80→- `counts` (required): Count matrix
    81→
    82→**Outputs:**
    83→- Size Factors: per-sample normalization factors
    84→- Normalized Counts: scaled count matrix
    85→
    86→**Example:**
    87→```yaml
    88→primitive: median_of_ratios
    89→inputs:
    90→  counts: counts.csv
    91→```
    92→
    93→### `upper_quartile`
    94→
    95→Upper quartile (75th percentile) normalization.
    96→
    97→**Inputs:**
    98→- `counts` (required): Count matrix
    99→
   100→**Outputs:**
   101→- Size Factors: per-sample normalization factors
   102→- Normalized Counts: scaled count matrix
   103→
   104→**Example:**
   105→```yaml
   106→primitive: upper_quartile
   107→inputs:
   108→  counts: counts.csv
   109→```
   110→
   111→---
   112→
   113→## Transforms
   114→
   115→### `clr`
   116→
   117→Centered log-ratio transform for compositional data.
   118→
   119→**Inputs:**
   120→- `counts` (required): Count matrix
   121→
   122→**Outputs:**
   123→- Transformed: CLR-transformed matrix
   124→
   125→**Parameters:**
   126→| Name | Type | Default | Description |
   127→|------|------|---------|-------------|
   128→| `pseudocount` | float | 0.5 | Added to zeros before log transform |
   129→
   130→**Example:**
   131→```yaml
   132→primitive: clr
   133→inputs:
   134→  counts: counts.csv
   135→params:
   136→  pseudocount: 0.5
   137→```
   138→
   139→### `vst`
   140→
   141→Variance stabilizing transformation.
   142→
   143→**Inputs:**
   144→- `counts` (required): Count matrix
   145→
   146→**Outputs:**
   147→- Transformed: VST-transformed matrix
   148→
   149→**Example:**
   150→```yaml
   151→primitive: vst
   152→inputs:
   153→  counts: counts.csv
   154→```
   155→
   156→### `rlog`
   157→
   158→Regularized log transformation.
   159→
   160→**Inputs:**
   161→- `counts` (required): Count matrix
   162→
   163→**Outputs:**
   164→- Transformed: rlog-transformed matrix
   165→
   166→**Example:**
   167→```yaml
   168→primitive: rlog
   169→inputs:
   170→  counts: counts.csv
   171→```
   172→
   173→### `log`
   174→
   175→Simple log transformation.
   176→
   177→**Parameters:**
   178→| Name | Type | Default | Description |
   179→|------|------|---------|-------------|
   180→| `base` | float | 2.0 | Log base (2, 10, or e) |
   181→| `pseudocount` | float | 1.0 | Added before log transform |
   182→
   183→### `zscore`
   184→
   185→Z-score standardization (mean=0, sd=1).
   186→
   187→---
   188→
   189→## Filtering
   190→
   191→### `filter_prevalence`
   192→
   193→Remove features present in fewer than X% of samples.
   194→
   195→**Parameters:**
   196→| Name | Type | Default | Description |
   197→|------|------|---------|-------------|
   198→| `min_prevalence` | float | 0.1 | Minimum fraction of samples (0-1) |
   199→
   200→**Example:**
   201→```yaml
   202→primitive: filter_prevalence
   203→inputs:
   204→  counts: counts.csv
   205→params:
   206→  min_prevalence: 0.1  # Present in at least 10% of samples
   207→```
   208→
   209→### `filter_abundance`
   210→
   211→Remove features with total count below threshold.
   212→
   213→**Parameters:**
   214→| Name | Type | Default | Description |
   215→|------|------|---------|-------------|
   216→| `min_count` | integer | 10 | Minimum total count |
   217→
   218→### `filter_variance`
   219→
   220→Remove low-variance features.
   221→
   222→**Parameters:**
   223→| Name | Type | Default | Description |
   224→|------|------|---------|-------------|
   225→| `min_variance` | float | 0.0 | Minimum variance threshold |
   226→
   227→---
   228→
   229→## Models
   230→
   231→### `fit_glm`
   232→
   233→Fit negative binomial GLM to each feature.
   234→
   235→**Inputs:**
   236→- `counts` (required): Count matrix
   237→- `groups` (required): Sample group assignments
   238→
   239→**Outputs:**
   240→- Coefficients: model coefficients per feature
   241→- Dispersions: estimated dispersions
   242→
   243→**Parameters:**
   244→| Name | Type | Default | Description |
   245→|------|------|---------|-------------|
   246→| `family` | enum | negative_binomial | Distribution family |
   247→| `shrink_dispersions` | bool | true | Apply dispersion shrinkage |
   248→
   249→**Example:**
   250→```yaml
   251→primitive: fit_glm
   252→inputs:
   253→  counts: counts.csv
   254→  groups: groups.txt
   255→params:
   256→  family: negative_binomial
   257→  shrink_dispersions: true
   258→```
   259→
   260→---
   261→
   262→## Statistical Tests
   263→
   264→### `wald`
   265→
   266→Wald test for significance of model coefficients.
   267→
   268→**Inputs:**
   269→- `counts` (required): Count matrix (with fitted model)
   270→
   271→**Outputs:**
   272→- P-Values: per-feature p-values
   273→- Test Statistics: Wald statistics
   274→
   275→### `lrt`
   276→
   277→Likelihood ratio test comparing full vs reduced model.
   278→
   279→### `score`
   280→
   281→Score test (Rao&#x27;s test).
   282→
   283→### `permutation`
   284→
   285→Permutation-based test for two-group comparison. Non-parametric inference.
   286→
   287→**Inputs:**
   288→- `transformed_counts` (required): Data values for comparison
   289→- `metadata` (required): Sample metadata CSV with grouping column
   290→
   291→**Parameters:**
   292→| Name | Type | Default | Description |
   293→|------|------|---------|-------------|
   294→| `grouping_column` | string | (required) | Column name in metadata (must have exactly 2 groups) |
   295→| `n_permutations` | integer | 10000 | Number of permutations |
   296→| `seed` | integer | 42 | Random seed |
   297→| `two_sided` | bool | true | Two-sided test |
   298→| `statistic` | string | mean | Statistic: &quot;mean&quot; or &quot;median&quot; |
   299→
   300→### `bootstrap`
   301→
   302→Bootstrap confidence intervals.
   303→
   304→**Parameters:**
   305→| Name | Type | Default | Description |
   306→|------|------|---------|-------------|
   307→| `n_bootstrap` | integer | 1000 | Number of bootstrap samples |
   308→| `confidence` | float | 0.95 | Confidence level |
   309→
   310→### `permanova`
   311→
   312→PERMANOVA: Permutational multivariate ANOVA for group differences.
   313→
   314→**Inputs:**
   315→- `distance_matrix` (required): Distance matrix from beta_diversity
   316→- `metadata` (required): Sample metadata CSV with grouping column
   317→
   318→**Outputs:**
   319→- P-Values: significance of group effect
   320→- Test Statistics: pseudo-F statistic
   321→
   322→**Parameters:**
   323→| Name | Type | Default | Description |
   324→|------|------|---------|-------------|
   325→| `grouping_column` | string | (required) | Column name in metadata for group assignments |
   326→| `n_permutations` | integer | 999 | Number of permutations |
   327→| `seed` | integer | -1 | Random seed |
   328→
   329→**Example:**
   330→```yaml
   331→primitive: permanova
   332→inputs:
   333→  distance_matrix: distance_matrix.csv
   334→  metadata: metadata.csv
   335→params:
   336→  grouping_column: Treatment
   337→  n_permutations: 999
   338→```
   339→
   340→### `anosim`
   341→
   342→ANOSIM: Analysis of similarities using rank-based R statistic.
   343→
   344→**Inputs:**
   345→- `distance_matrix` (required): Distance matrix from beta_diversity
   346→- `metadata` (required): Sample metadata CSV with grouping column
   347→
   348→**Outputs:**
   349→- P-Values: significance
   350→- Test Statistics: R statistic (-1 to 1, higher = more different)
   351→
   352→**Parameters:**
   353→| Name | Type | Default | Description |
   354→|------|------|---------|-------------|
   355→| `grouping_column` | string | (required) | Column name in metadata for group assignments |
   356→| `n_permutations` | integer | 999 | Number of permutations |
   357→
   358→**Example:**
   359→```yaml
   360→primitive: anosim
   361→inputs:
   362→  distance_matrix: distance_matrix.csv
   363→  metadata: metadata.csv
   364→params:
   365→  grouping_column: Treatment
   366→  n_permutations: 999
   367→```
   368→
   369→### `mrpp`
   370→
   371→MRPP (Multi-Response Permutation Procedure) tests whether groups differ significantly using within-group distance analysis.
   372→
   373→**Inputs:**
   374→- `distance_matrix` (required): Distance matrix from beta_diversity
   375→- `metadata` (required): Sample metadata CSV with grouping column
   376→
   377→**Outputs:**
   378→- Test Statistics: A statistic (chance-corrected within-group agreement, 0-1)
   379→- P-Values: Permutation-based p-value
   380→
   381→**Parameters:**
   382→| Name | Type | Default | Description |
   383→|------|------|---------|-------------|
   384→| `grouping_column` | string | (required) | Column name in metadata for group assignments |
   385→| `n_permutations` | integer | 999 | Number of permutations |
   386→| `weight_type` | enum | &quot;n-1&quot; | Weight type: &quot;n&quot;, &quot;n-1&quot;, or &quot;n(n-1)&quot; |
   387→| `seed` | integer | -1 | Random seed (-1 for random) |
   388→
   389→**Example:**
   390→```yaml
   391→primitive: mrpp
   392→inputs:
   393→  distance_matrix: distance_matrix.csv
   394→  metadata: metadata.csv
   395→params:
   396→  grouping_column: Treatment
   397→  n_permutations: 999
   398→  weight_type: &quot;n-1&quot;
   399→```
   400→
   401→**Interpreting Results:**
   402→- **A = 1**: All samples within groups are identical
   403→- **A = 0**: Within-group heterogeneity equals expectation by chance
   404→- **A &lt; 0**: More heterogeneous than expected (unusual)
   405→- **A &gt; 0.3**: Fairly strong group separation (ecological rule of thumb)
   406→
   407→**Comparison with PERMANOVA and ANOSIM:**
   408→- MRPP: Uses within-group distances only, weighted by group size
   409→- ANOSIM: Uses ranks of distances, compares within vs between
   410→- PERMANOVA: Uses sums of squares, tests centroid differences
   411→
   412→MRPP is often preferred when group sizes are unequal because the weighting options can adjust for sample size differences.
   413→
   414→### `indicator_species`
   415→
   416→Indicator species analysis using the IndVal method (Dufrêne &amp; Legendre, 1997). Identifies features characteristic of specific groups.
   417→
   418→**Inputs:**
   419→- `counts` (required): Count matrix with features as rows
   420→- `metadata` (required): Sample metadata with grouping column
   421→
   422→**Outputs:**
   423→- Test Statistics: IndVal scores (0-100) for each feature
   424→- P-Values: Permutation-based p-values
   425→- Sample Groups: Group assignments used
   426→
   427→**Parameters:**
   428→| Name | Type | Default | Description |
   429→|------|------|---------|-------------|
   430→| `grouping_column` | string | (required) | Column name in metadata for group assignments |
   431→| `n_permutations` | integer | 999 | Number of permutations for p-value calculation |
   432→| `seed` | integer | -1 | Random seed (-1 for random) |
   433→| `min_indval` | float | 25.0 | Minimum IndVal threshold for reporting (0-100) |
   434→| `alpha` | float | 0.05 | Significance level |
   435→
   436→**Example:**
   437→```yaml
   438→primitive: indicator_species
   439→inputs:
   440→  counts: counts.csv
   441→  metadata: metadata.csv
   442→params:
   443→  grouping_column: Treatment
   444→  n_permutations: 999
   445→```
   446→
   447→**Interpreting IndVal:**
   448→- IndVal = Specificity × Fidelity × 100
   449→- **Specificity**: How concentrated a feature&#x27;s abundance is within a group
   450→- **Fidelity**: How consistently a feature appears across sites within a group
   451→- **IndVal = 100**: Perfect indicator (only in that group, present in all sites)
   452→- **IndVal &gt; 70**: Strong indicator
   453→- **IndVal &gt; 25**: Moderate indicator (default threshold)
   454→
   455→### `simper`
   456→
   457→SIMPER (Similarity Percentages) decomposes Bray-Curtis dissimilarity between groups to identify which features contribute most to the observed differences.
   458→
   459→**Inputs:**
   460→- `counts` (required): Count matrix with features as rows
   461→- `metadata` (required): Sample metadata with grouping column
   462→
   463→**Outputs:**
   464→- Test Statistics: Average contribution of each feature to dissimilarity
   465→- Feature Rankings: Features ordered by contribution (descending)
   466→
   467→**Parameters:**
   468→| Name | Type | Default | Description |
   469→|------|------|---------|-------------|
   470→| `grouping_column` | string | (required) | Column name in metadata for group assignments |
   471→| `group1` | string | null | First group to compare (if null, compares all pairs) |
   472→| `group2` | string | null | Second group to compare (if null, compares all pairs) |
   473→| `top_n` | integer | 20 | Number of top contributing features to report |
   474→| `cumsum_threshold` | float | 0.7 | Cumulative contribution threshold (0-1) |
   475→
   476→**Example:**
   477→```yaml
   478→primitive: simper
   479→inputs:
   480→  counts: counts.csv
   481→  metadata: metadata.csv
   482→params:
   483→  grouping_column: Treatment
   484→  top_n: 20
   485→```
   486→
   487→**Interpreting SIMPER:**
   488→- **Average contribution**: Mean contribution of each feature to between-group dissimilarity
   489→- **SD**: Standard deviation of contribution across sample pairs
   490→- **Ratio (average/SD)**: Consistency measure - higher = more reliable discriminator
   491→- **Percentage**: Feature&#x27;s contribution as % of total dissimilarity
   492→- **Cumulative %**: Running sum (first few features often explain 70%+ of difference)
   493→
   494→**Key Insights:**
   495→- High contribution + high ratio = reliable discriminating feature
   496→- High contribution + low ratio = inconsistent (varies across sample pairs)
   497→- SIMPER does not test significance - pair with PERMANOVA/ANOSIM for inference
   498→
   499→---
   500→
   501→## Multiple Testing Correction
   502→
   503→### `benjamini_hochberg`
   504→
   505→Benjamini-Hochberg FDR correction. Controls expected false discovery proportion.
   506→
   507→**Inputs:**
   508→- P-values from previous test
   509→
   510→**Outputs:**
   511→- Adjusted P-Values (q-values)
   512→
   513→**Example:**
   514→```yaml
   515→primitive: benjamini_hochberg
   516→inputs:
   517→  counts: counts.csv  # Must have p-values from prior test
   518→```
   519→
   520→### `qvalue`
   521→
   522→Storey&#x27;s q-value. More powerful than BH by estimating proportion of true nulls.
   523→
   524→### `bonferroni`
   525→
   526→Bonferroni FWER correction. Most conservative.
   527→
   528→### `holm`
   529→
   530→Holm step-down. Less conservative than Bonferroni.
   531→
   532→### `local_fdr`
   533→
   534→Local false discovery rate. Per-test probability of being false positive.
   535→
   536→---
   537→
   538→## Diversity
   539→
   540→### `alpha_diversity`
   541→
   542→Within-sample diversity metrics.
   543→
   544→**Inputs:**
   545→- `counts` (required): Count matrix
   546→
   547→**Outputs:**
   548→- Alpha Diversity: dict of metric name -&gt; values per sample
   549→
   550→**Parameters:**
   551→| Name | Type | Default | Description |
   552→|------|------|---------|-------------|
   553→| `metrics` | enum | all | Which metrics: all, shannon, simpson, observed, chao1 |
   554→
   555→**Example:**
   556→```yaml
   557→primitive: alpha_diversity
   558→inputs:
   559→  counts: counts.csv
   560→params:
   561→  metrics: all
   562→```
   563→
   564→**Metrics:**
   565→- `shannon`: Shannon entropy (H&#x27;)
   566→- `simpson`: Simpson&#x27;s diversity (1-D)
   567→- `observed`: Observed richness (count of non-zero features)
   568→- `chao1`: Chao1 richness estimator
   569→
   570→### `beta_diversity`
   571→
   572→Between-sample distance matrix.
   573→
   574→**Inputs:**
   575→- `counts` (required): Count matrix
   576→
   577→**Outputs:**
   578→- Distance Matrix: pairwise distances between samples
   579→
   580→**Parameters:**
   581→| Name | Type | Default | Description |
   582→|------|------|---------|-------------|
   583→| `metric` | enum | bray_curtis | Distance metric |
   584→
   585→**Metrics:**
   586→- `bray_curtis`: Bray-Curtis dissimilarity (abundance-weighted)
   587→- `jaccard`: Jaccard distance (presence/absence)
   588→- `euclidean`: Euclidean distance
   589→- `aitchison`: Aitchison distance (compositional)
   590→
   591→**Example:**
   592→```yaml
   593→primitive: beta_diversity
   594→inputs:
   595→  counts: counts.csv
   596→params:
   597→  metric: bray_curtis
   598→```
   599→
   600→---
   601→
   602→## Ordination
   603→
   604→### `pca`
   605→
   606→Principal Component Analysis.
   607→
   608→**Inputs:**
   609→- `counts` (required): Count matrix (recommend transformed data)
   610→
   611→**Outputs:**
   612→- Coordinates: sample positions in PC space
   613→- Variance Explained: per-component variance
   614→
   615→**Parameters:**
   616→| Name | Type | Default | Description |
   617→|------|------|---------|-------------|
   618→| `n_components` | integer | 2 | Number of components |
   619→| `scale` | bool | true | Scale features to unit variance |
   620→
   621→### `pcoa`
   622→
   623→Principal Coordinates Analysis (classical MDS).
   624→
   625→**Inputs:**
   626→- `counts` (required): Count matrix (or distance matrix from beta_diversity)
   627→
   628→**Outputs:**
   629→- Coordinates: sample positions
   630→- Variance Explained: per-axis variance
   631→
   632→**Parameters:**
   633→| Name | Type | Default | Description |
   634→|------|------|---------|-------------|
   635→| `n_components` | integer | 2 | Number of axes |
   636→| `metric` | enum | bray_curtis | Distance metric (if counts provided) |
   637→
   638→**Example:**
   639→```yaml
   640→primitive: pcoa
   641→inputs:
   642→  counts: counts.csv
   643→params:
   644→  n_components: 2
   645→  metric: bray_curtis
   646→```
   647→
   648→### `nmds`
   649→
   650→Non-metric Multidimensional Scaling.
   651→
   652→**Inputs:**
   653→- Distance matrix (from beta_diversity)
   654→
   655→**Outputs:**
   656→- Coordinates: sample positions
   657→- Stress: goodness of fit (lower is better, &lt;0.1 is good)
   658→
   659→**Parameters:**
   660→| Name | Type | Default | Description |
   661→|------|------|---------|-------------|
   662→| `n_components` | integer | 2 | Number of dimensions |
   663→| `max_iter` | integer | 500 | Maximum iterations |
   664→
   665→---
   666→
   667→## Visualization
   668→
   669→### `scatter_plot`
   670→
   671→Create a scatter plot from ordination results or data coordinates.
   672→
   673→**Inputs:**
   674→- `coordinates` (required): Coordinate data (e.g., from PCoA, PCA, NMDS)
   675→
   676→**Outputs:**
   677→- PlotSpec: Scatter plot specification for rendering
   678→
   679→**Parameters:**
   680→| Name | Type | Default | Description |
   681→|------|------|---------|-------------|
   682→| `title` | string | &quot;Scatter Plot&quot; | Plot title |
   683→| `x` | string | &quot;PC1&quot; | X axis field name |
   684→| `y` | string | &quot;PC2&quot; | Y axis field name |
   685→| `color_by` | string | null | Field for color encoding |
   686→| `size_by` | string | null | Field for size encoding |
   687→| `shape_by` | string | null | Field for shape encoding |
   688→
   689→**Example:**
   690→```yaml
   691→primitive: scatter_plot
   692→inputs:
   693→  coordinates: pcoa_coords.csv
   694→params:
   695→  title: &quot;PCoA Ordination&quot;
   696→  x: PC1
   697→  y: PC2
   698→  color_by: Treatment
   699→```
   700→
   701→### `query_plot`
   702→
   703→Query a plot to find specific points by criteria.
   704→
   705→**Inputs:**
   706→- `plot` (required): PlotSpec to query
   707→
   708→**Parameters:**
   709→| Name | Type | Default | Description |
   710→|------|------|---------|-------------|
   711→| `query` | string | &quot;extremes&quot; | Query type: max_x, max_y, min_x, min_y, extremes, by_id |
   712→| `point_id` | string | null | Point ID for by_id query |
   713→| `top_n` | integer | 5 | Number of results to return |
   714→
   715→**Example:**
   716→```yaml
   717→primitive: query_plot
   718→inputs:
   719→  plot: ordination_plot.json
   720→params:
   721→  query: max_x
   722→  top_n: 3
   723→```
   724→
   725→### `annotate_plot`
   726→
   727→Add annotations (labels, reference lines) to a plot.
   728→
   729→**Inputs:**
   730→- `plot` (required): PlotSpec to annotate
   731→
   732→**Outputs:**
   733→- PlotSpec: New plot with annotations
   734→
   735→**Parameters:**
   736→| Name | Type | Default | Description |
   737→|------|------|---------|-------------|
   738→| `point_labels` | string | null | JSON array of {point_id, text} |
   739→| `hlines` | string | null | JSON array of {y, label} for horizontal lines |
   740→| `vlines` | string | null | JSON array of {x, label} for vertical lines |
   741→
   742→**Example:**
   743→```yaml
   744→primitive: annotate_plot
   745→inputs:
   746→  plot: ordination_plot.json
   747→params:
   748→  point_labels: &#x27;[{&quot;point_id&quot;: &quot;sample1&quot;, &quot;text&quot;: &quot;Outlier&quot;}]&#x27;
   749→  hlines: &#x27;[{&quot;y&quot;: 0, &quot;label&quot;: &quot;Origin&quot;}]&#x27;
   750→```
   751→
   752→### `filter_plot`
   753→
   754→Filter points from a plot by coordinate bounds, IDs, or metadata.
   755→
   756→**Inputs:**
   757→- `plot` (required): PlotSpec to filter
   758→
   759→**Outputs:**
   760→- PlotSpec: Filtered plot with lineage tracking
   761→
   762→**Parameters:**
   763→| Name | Type | Default | Description |
   764→|------|------|---------|-------------|
   765→| `x_min` | float | null | Minimum x value |
   766→| `x_max` | float | null | Maximum x value |
   767→| `y_min` | float | null | Minimum y value |
   768→| `y_max` | float | null | Maximum y value |
   769→| `ids` | string | null | JSON array of point IDs to keep |
   770→| `exclude_ids` | string | null | JSON array of point IDs to exclude |
   771→
   772→**Example:**
   773→```yaml
   774→primitive: filter_plot
   775→inputs:
   776→  plot: ordination_plot.json
   777→params:
   778→  x_min: -0.5
   779→  x_max: 0.5
   780→```
   781→
   782→### `restyle_plot`
   783→
   784→Change the visual encoding of a plot (color, size, shape mappings).
   785→
   786→**Inputs:**
   787→- `plot` (required): PlotSpec to restyle
   788→
   789→**Outputs:**
   790→- PlotSpec: Restyled plot with lineage tracking
   791→
   792→**Parameters:**
   793→| Name | Type | Default | Description |
   794→|------|------|---------|-------------|
   795→| `color_by` | string | null | Field for color encoding |
   796→| `color_categorical` | boolean | true | Whether color field is categorical |
   797→| `size_by` | string | null | Field for size encoding |
   798→| `shape_by` | string | null | Field for shape encoding |
   799→
   800→**Example:**
   801→```yaml
   802→primitive: restyle_plot
   803→inputs:
   804→  plot: ordination_plot.json
   805→params:
   806→  color_by: Timepoint
   807→  size_by: Age
   808→```
   809→
   810→---
   811→
   812→## Data Flow Notes
   813→
   814→Many primitives produce outputs that subsequent primitives consume:
   815→
   816→```
   817→diagnose → recommendations guide method choices
   818→    ↓
   819→tmm/median_of_ratios → size_factors stored in session
   820→    ↓
   821→fit_glm → coefficients, dispersions stored
   822→    ↓
   823→wald/lrt → p_values stored
   824→    ↓
   825→benjamini_hochberg → adjusted_p_values stored
   826→```
   827→
   828→The daemon automatically carries forward session state, so you don&#x27;t need to manually pass intermediate results.
   829→

&lt;system-reminder&gt;
Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
&lt;/system-reminder&gt;
</pre></div><button class="expand-btn">Show more</button></div></div></div></div>
<div class="message tool-reply" id="msg-2025-12-19T21-56-19-192Z"><div class="message-header"><span class="role-label">Tool reply</span><a href="#msg-2025-12-19T21-56-19-192Z" class="timestamp-link"><time datetime="2025-12-19T21:56:19.192Z" data-timestamp="2025-12-19T21:56:19.192Z">2025-12-19T21:56:19.192Z</time></a></div><div class="message-content"><div class="tool-result"><div class="truncatable"><div class="truncatable-content"><pre>     1→# Interpreting BioStack Results
     2→
     3→Guide for explaining statistical outputs to users. Don&#x27;t just report numbers - provide context and meaning.
     4→
     5→---
     6→
     7→## Diagnose Output
     8→
     9→### Quality Score
    10→- **0.8-1.0**: Excellent data quality, standard methods should work well
    11→- **0.6-0.8**: Good quality, may need some filtering or careful method selection
    12→- **0.4-0.6**: Moderate issues, follow recommendations carefully
    13→- **&lt; 0.4**: Significant data challenges, consider additional QC or data collection
    14→
    15→### Sample Size Assessment
    16→```json
    17→&quot;sample_size&quot;: {
    18→  &quot;n_samples&quot;: 12,
    19→  &quot;n_features&quot;: 5000,
    20→  &quot;supports_parametric&quot;: true
    21→}
    22→```
    23→- **supports_parametric: true**: Standard statistical tests are appropriate
    24→- **supports_parametric: false**: Consider permutation tests; explain that small sample size limits statistical power
    25→
    26→### Sparsity Levels
    27→| Level | Meaning | Action |
    28→|-------|---------|--------|
    29→| Low (&lt; 30%) | Most features detected in most samples | Standard analysis |
    30→| Moderate (30-60%) | Common in microbiome data | Consider filtering low-prevalence |
    31→| High (60-80%) | Many zeros, typical of sparse data | Use zero-aware methods |
    32→| Extreme (&gt; 80%) | Highly sparse | Strong filtering, consider zero-inflated models |
    33→
    34→### Overdispersion
    35→- **NoOverdispersion**: Poisson model may suffice
    36→- **MildOverdispersion**: Negative binomial recommended (typical for count data)
    37→- **StrongOverdispersion**: Negative binomial essential; explain variance &gt; mean
    38→
    39→### Recommendations Confidence
    40→- **&gt; 0.8**: High confidence in recommendations
    41→- **0.6-0.8**: Reasonable confidence, explain rationale to user
    42→- **&lt; 0.6**: Low confidence; multiple approaches may be valid, discuss options
    43→
    44→---
    45→
    46→## Normalization Results
    47→
    48→### Size Factors
    49→```json
    50→&quot;Size Factors&quot;: [0.85, 1.12, 0.95, 1.08]
    51→```
    52→
    53→**How to interpret:**
    54→- Values close to 1.0 indicate similar library sizes
    55→- Low values (&lt; 0.5) indicate samples with fewer total counts
    56→- High values (&gt; 2.0) indicate samples with many more counts
    57→- Very uneven factors suggest strong library size differences
    58→
    59→**What to tell users:**
    60→&gt; &quot;Size factors range from 0.85 to 1.12, indicating relatively consistent sequencing depth across samples. Sample 2 had slightly higher counts (factor 1.12) which will be corrected in downstream analysis.&quot;
    61→
    62→---
    63→
    64→## Differential Analysis Results
    65→
    66→### P-values
    67→- **p &lt; 0.001**: Very strong evidence
    68→- **p &lt; 0.01**: Strong evidence
    69→- **p &lt; 0.05**: Moderate evidence (conventional threshold)
    70→- **p &gt; 0.05**: Insufficient evidence (not &quot;no effect&quot;)
    71→
    72→**Never say &quot;no difference&quot;** for p &gt; 0.05. Say &quot;insufficient evidence to detect a difference.&quot;
    73→
    74→### Adjusted P-values (FDR)
    75→- **FDR &lt; 0.01**: Very confident these are true positives
    76→- **FDR &lt; 0.05**: ~5% of &quot;significant&quot; results may be false positives
    77→- **FDR &lt; 0.10**: Acceptable for exploratory analysis
    78→
    79→**What to tell users:**
    80→&gt; &quot;Of the 150 significant features at FDR &lt; 0.05, we expect approximately 7-8 to be false positives. This is a conservative threshold suitable for follow-up validation.&quot;
    81→
    82→### Log2 Fold Change
    83→| |log2FC| | Fold Change | Interpretation |
    84→|----------|-------------|----------------|
    85→| &lt; 0.5 | &lt; 1.4x | Small effect |
    86→| 0.5-1.0 | 1.4-2x | Moderate effect |
    87→| 1.0-2.0 | 2-4x | Large effect |
    88→| &gt; 2.0 | &gt; 4x | Very large effect |
    89→
    90→**Combine significance and effect size:**
    91→&gt; &quot;Gene X shows a 3.2-fold increase (log2FC = 1.68) in treatment vs control, with high confidence (adjusted p = 0.002).&quot;
    92→
    93→---
    94→
    95→## Diversity Metrics
    96→
    97→### Alpha Diversity
    98→
    99→**Shannon Index (H&#x27;)**
   100→| Value | Interpretation |
   101→|-------|----------------|
   102→| &lt; 2.0 | Low diversity (few dominant species) |
   103→| 2.0-3.5 | Moderate diversity |
   104→| &gt; 3.5 | High diversity (many evenly abundant species) |
   105→
   106→**Simpson Index (1-D)**
   107→| Value | Interpretation |
   108→|-------|----------------|
   109→| &lt; 0.5 | Low diversity (high dominance) |
   110→| 0.5-0.8 | Moderate diversity |
   111→| &gt; 0.8 | High diversity (low dominance) |
   112→
   113→**Chao1**
   114→- Estimates true richness including unobserved species
   115→- If Chao1 &gt;&gt; Observed, many rare species likely undetected
   116→
   117→**What to tell users:**
   118→&gt; &quot;Treatment group shows higher Shannon diversity (3.8 vs 2.9), suggesting a more even community structure with no single dominant taxon.&quot;
   119→
   120→### Beta Diversity
   121→
   122→**Distance values** (Bray-Curtis, Jaccard):
   123→- 0 = identical communities
   124→- 1 = completely different communities
   125→
   126→**Interpret clustering:**
   127→&gt; &quot;Samples from the same treatment group cluster together (average within-group distance 0.25 vs between-group distance 0.65), indicating treatment has a strong effect on community composition.&quot;
   128→
   129→---
   130→
   131→## PERMANOVA / ANOSIM
   132→
   133→### PERMANOVA (pseudo-F)
   134→- Higher F = greater between-group vs within-group variance
   135→- P-value from permutation distribution
   136→
   137→**What to tell users:**
   138→&gt; &quot;PERMANOVA shows a significant effect of treatment on community composition (F = 4.2, p = 0.001). Treatment explains approximately 28% of the variation (R² = 0.28).&quot;
   139→
   140→### ANOSIM (R statistic)
   141→| R value | Interpretation |
   142→|---------|----------------|
   143→| &lt; 0 | Within-group more different than between-group (unusual) |
   144→| ~0 | No difference between groups |
   145→| 0.25-0.5 | Weak separation |
   146→| 0.5-0.75 | Moderate separation |
   147→| &gt; 0.75 | Strong separation |
   148→
   149→**What to tell users:**
   150→&gt; &quot;ANOSIM R = 0.68 (p = 0.001) indicates moderate-to-strong separation between treatment groups, meaning samples within each group are more similar to each other than to samples from the other group.&quot;
   151→
   152→### MRPP (A statistic)
   153→
   154→MRPP tests group differences using within-group distances. The A statistic measures chance-corrected within-group agreement.
   155→
   156→| A value | Interpretation |
   157→|---------|----------------|
   158→| = 1 | Perfect agreement (all samples in each group are identical) |
   159→| &gt; 0.3 | Fairly strong group separation (ecological rule of thumb) |
   160→| 0.1-0.3 | Weak to moderate separation |
   161→| ~0 | Within-group heterogeneity equals random expectation |
   162→| &lt; 0 | More heterogeneous than expected by chance (unusual) |
   163→
   164→**What to tell users:**
   165→&gt; &quot;MRPP shows significant group separation (A = 0.42, p = 0.001). The A statistic of 0.42 indicates fairly strong within-group homogeneity, meaning samples in the same group are substantially more similar to each other than expected by chance.&quot;
   166→
   167→**Comparison with PERMANOVA/ANOSIM:**
   168→- MRPP focuses on within-group distances only
   169→- Better for unequal group sizes (weight_type adjusts for this)
   170→- A statistic is intuitive: 1 = identical groups, 0 = random
   171→
   172→---
   173→
   174→## Indicator Species Analysis
   175→
   176→### IndVal (Indicator Value)
   177→
   178→IndVal identifies species/features characteristic of specific groups. It combines specificity (concentration in a group) and fidelity (presence across sites).
   179→
   180→| IndVal | Interpretation |
   181→|--------|----------------|
   182→| 100 | Perfect indicator (only in that group, present in all sites) |
   183→| &gt; 70 | Strong indicator |
   184→| 25-70 | Moderate indicator |
   185→| &lt; 25 | Weak indicator |
   186→
   187→**Components:**
   188→- **Specificity**: How concentrated the feature&#x27;s abundance is within a group
   189→- **Fidelity**: How consistently the feature appears across sites within a group
   190→
   191→**What to tell users:**
   192→&gt; &quot;Feature X is a strong indicator of the Treatment group (IndVal = 78.5, p = 0.002). It shows high specificity (mostly found in Treatment samples) and high fidelity (present in most Treatment samples).&quot;
   193→
   194→**Reporting multiple indicators:**
   195→&gt; &quot;We identified 15 significant indicator features (IndVal &gt; 25, p &lt; 0.05). The top indicators for the Treatment group are Feature A (IndVal = 92), Feature B (IndVal = 85), and Feature C (IndVal = 71).&quot;
   196→
   197→---
   198→
   199→## SIMPER Analysis
   200→
   201→SIMPER (Similarity Percentages) decomposes Bray-Curtis dissimilarity to identify which features drive differences between groups. Unlike PERMANOVA/ANOSIM, SIMPER is descriptive rather than inferential.
   202→
   203→### Key Output Metrics
   204→
   205→**Average Contribution:**
   206→- Mean contribution of each feature to between-group dissimilarity
   207→- Higher values = feature contributes more to observed differences
   208→
   209→**Standard Deviation (SD):**
   210→- Variability of contribution across sample pairs
   211→- High SD = inconsistent contribution (varies between pairs)
   212→
   213→**Ratio (Average/SD):**
   214→| Ratio | Interpretation |
   215→|-------|----------------|
   216→| &gt; 1.5 | Consistent discriminator |
   217→| &gt; 2 | Very consistent (reliable) |
   218→| &lt; 1 | Inconsistent (high variability) |
   219→
   220→**Percentage Contribution:**
   221→- Feature&#x27;s % of total dissimilarity
   222→- First few features often explain 70%+ of difference
   223→
   224→**Cumulative Percentage:**
   225→- Running sum of contributions
   226→- &quot;Features to 70%&quot; = minimum set driving most of the difference
   227→
   228→### What to Tell Users
   229→
   230→**For strong discriminators:**
   231→&gt; &quot;Feature X contributes 23% of the dissimilarity between Treatment and Control groups (ratio = 2.4), making it a reliable discriminator. Treatment samples show 5× higher abundance of this feature.&quot;
   232→
   233→**For inconsistent features:**
   234→&gt; &quot;Feature Y has high average contribution (15%) but low ratio (0.8), meaning its discriminatory power varies across sample pairs. This may reflect high within-group variability.&quot;
   235→
   236→**Summary statement:**
   237→&gt; &quot;SIMPER analysis shows the top 5 features (Feature A, B, C, D, E) account for 72% of the observed dissimilarity between groups. Feature A alone explains 28% of the difference with high consistency (ratio = 2.1).&quot;
   238→
   239→### Pairing with Hypothesis Tests
   240→
   241→SIMPER does not test significance. Always pair with:
   242→- **PERMANOVA**: Test if groups differ significantly
   243→- **ANOSIM**: Test group separation using ranks
   244→- **MRPP**: Test within-group homogeneity
   245→
   246→**Typical workflow:**
   247→&gt; &quot;PERMANOVA confirms significant community differences (F = 4.2, p = 0.001). SIMPER decomposition shows this difference is primarily driven by Feature A (28%) and Feature B (19%), both with high ratio values indicating reliable discrimination.&quot;
   248→
   249→---
   250→
   251→## Ordination Results
   252→
   253→### PCoA / PCA
   254→
   255→**Variance explained:**
   256→- PC1 + PC2 &gt; 50%: Good representation in 2D
   257→- PC1 + PC2 = 30-50%: Moderate, higher dimensions may be informative
   258→- PC1 + PC2 &lt; 30%: High-dimensional structure, 2D may miss patterns
   259→
   260→**What to tell users:**
   261→&gt; &quot;The first two principal coordinates explain 45% of the variation. Treatment groups separate primarily along PC1, which captures 32% of the variance.&quot;
   262→
   263→### NMDS
   264→
   265→**Stress:**
   266→| Stress | Interpretation |
   267→|--------|----------------|
   268→| &lt; 0.05 | Excellent representation |
   269→| 0.05-0.1 | Good representation |
   270→| 0.1-0.2 | Acceptable but interpret cautiously |
   271→| &gt; 0.2 | Poor representation, increase dimensions |
   272→
   273→---
   274→
   275→## Communicating Uncertainty
   276→
   277→Always include:
   278→1. **Sample size context**: &quot;With only 6 samples per group, statistical power is limited&quot;
   279→2. **Effect size**: &quot;The difference is statistically significant but small in magnitude&quot;
   280→3. **Multiple testing burden**: &quot;After correcting for 5000 tests, 150 remain significant&quot;
   281→4. **Confidence intervals** when available
   282→
   283→**Avoid:**
   284→- &quot;Proves&quot; or &quot;confirms&quot; (science doesn&#x27;t prove)
   285→- &quot;No effect&quot; for non-significant results
   286→- P-value alone without effect size
   287→- Over-interpreting borderline results (p = 0.049)
   288→

&lt;system-reminder&gt;
Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
&lt;/system-reminder&gt;
</pre></div><button class="expand-btn">Show more</button></div></div></div></div>
<div class="message tool-reply" id="msg-2025-12-19T21-56-19-192Z"><div class="message-header"><span class="role-label">Tool reply</span><a href="#msg-2025-12-19T21-56-19-192Z" class="timestamp-link"><time datetime="2025-12-19T21:56:19.192Z" data-timestamp="2025-12-19T21:56:19.192Z">2025-12-19T21:56:19.192Z</time></a></div><div class="message-content"><div class="tool-result"><div class="truncatable"><div class="truncatable-content"><pre>     1→# Standard Workflows
     2→
     3→Use these established workflows when the user explicitly requests them (e.g., &quot;run DESeq2&quot;, &quot;do vegan analysis&quot;). These provide reproducible, comparable results using well-known methods.
     4→
     5→**For data-driven analysis, use `diagnose` recommendations instead.** See SKILL.md.
     6→
     7→---
     8→
     9→## DESeq2-Style Differential Expression
    10→
    11→**When to use:** User says &quot;DESeq2&quot;, &quot;differential expression&quot;, or wants RNA-seq analysis comparable to R/DESeq2.
    12→
    13→**Pipeline:**
    14→```yaml
    15→# 1. Normalize with Median of Ratios (DESeq2&#x27;s method)
    16→primitive: median_of_ratios
    17→inputs:
    18→  counts: counts.csv
    19→
    20→# 2. Fit negative binomial GLM with shrinkage
    21→primitive: fit_glm
    22→inputs:
    23→  counts: counts.csv
    24→  groups: groups.txt
    25→params:
    26→  family: negative_binomial
    27→  shrink_dispersions: true
    28→
    29→# 3. Wald test for significance
    30→primitive: wald
    31→inputs:
    32→  counts: counts.csv
    33→
    34→# 4. Benjamini-Hochberg FDR correction
    35→primitive: benjamini_hochberg
    36→inputs:
    37→  counts: counts.csv
    38→```
    39→
    40→**Expected outputs:**
    41→- Size factors (normalization)
    42→- Log2 fold changes
    43→- P-values and adjusted p-values
    44→- Significant features at FDR &lt; 0.05
    45→
    46→---
    47→
    48→## edgeR-Style Differential Expression
    49→
    50→**When to use:** User says &quot;edgeR&quot; or wants TMM normalization.
    51→
    52→**Pipeline:**
    53→```yaml
    54→# 1. TMM normalization
    55→primitive: tmm
    56→inputs:
    57→  counts: counts.csv
    58→params:
    59→  trim_m: 0.3
    60→  trim_a: 0.05
    61→
    62→# 2. Fit negative binomial GLM
    63→primitive: fit_glm
    64→inputs:
    65→  counts: counts.csv
    66→  groups: groups.txt
    67→params:
    68→  family: negative_binomial
    69→
    70→# 3. Likelihood ratio test
    71→primitive: lrt
    72→inputs:
    73→  counts: counts.csv
    74→
    75→# 4. BH correction
    76→primitive: benjamini_hochberg
    77→inputs:
    78→  counts: counts.csv
    79→```
    80→
    81→---
    82→
    83→## Vegan-Style Microbiome Analysis
    84→
    85→**When to use:** User says &quot;vegan&quot;, &quot;microbiome diversity&quot;, or wants ecological analysis comparable to R/vegan.
    86→
    87→### Alpha Diversity
    88→```yaml
    89→primitive: alpha_diversity
    90→inputs:
    91→  counts: counts.csv
    92→params:
    93→  metrics: all  # shannon, simpson, chao1, observed
    94→```
    95→
    96→### Beta Diversity + Ordination
    97→```yaml
    98→# 1. Calculate Bray-Curtis distances
    99→primitive: beta_diversity
   100→inputs:
   101→  counts: counts.csv
   102→params:
   103→  metric: bray_curtis
   104→
   105→# 2. PCoA ordination
   106→primitive: pcoa
   107→inputs:
   108→  counts: counts.csv
   109→params:
   110→  metric: bray_curtis
   111→  n_components: 2
   112→```
   113→
   114→### Group Comparison (PERMANOVA)
   115→```yaml
   116→# First calculate beta diversity
   117→primitive: beta_diversity
   118→inputs:
   119→  counts: counts.csv
   120→params:
   121→  metric: bray_curtis
   122→
   123→# Then run PERMANOVA
   124→primitive: permanova
   125→inputs:
   126→  distance_matrix: distance_matrix.csv
   127→  metadata: metadata.csv
   128→params:
   129→  grouping_column: Treatment
   130→  n_permutations: 999
   131→```
   132→
   133→### Alternative: ANOSIM
   134→```yaml
   135→primitive: anosim
   136→inputs:
   137→  distance_matrix: distance_matrix.csv
   138→  metadata: metadata.csv
   139→params:
   140→  grouping_column: Treatment
   141→  n_permutations: 999
   142→```
   143→
   144→### Alternative: MRPP (for unequal group sizes)
   145→
   146→MRPP is often preferred when group sizes are unequal because the weighting options can adjust for sample size differences.
   147→
   148→```yaml
   149→primitive: mrpp
   150→inputs:
   151→  distance_matrix: distance_matrix.csv
   152→  metadata: metadata.csv
   153→params:
   154→  grouping_column: Treatment
   155→  n_permutations: 999
   156→  weight_type: &quot;n-1&quot;  # Adjusts for unequal groups
   157→```
   158→
   159→**When to use MRPP vs PERMANOVA/ANOSIM:**
   160→- MRPP: Unequal group sizes, focus on within-group homogeneity
   161→- ANOSIM: Rank-based, robust to outliers
   162→- PERMANOVA: Tests centroid differences, most commonly used
   163→
   164→### Feature Decomposition: SIMPER
   165→
   166→After confirming significant group differences with PERMANOVA/ANOSIM/MRPP, use SIMPER to identify which features drive those differences.
   167→
   168→```yaml
   169→primitive: simper
   170→inputs:
   171→  counts: counts.csv
   172→  metadata: metadata.csv
   173→params:
   174→  grouping_column: Treatment
   175→  top_n: 20
   176→```
   177→
   178→**Typical workflow:**
   179→1. Run PERMANOVA → confirms groups differ (p &lt; 0.05)
   180→2. Run SIMPER → identifies features driving the difference
   181→3. Report top contributors with their % contribution and ratio
   182→
   183→**Note:** SIMPER is descriptive (no p-values). Always pair with a hypothesis test.
   184→
   185→### Indicator Species Analysis
   186→
   187→For identifying features characteristic of specific groups (presence-based):
   188→
   189→```yaml
   190→primitive: indicator_species
   191→inputs:
   192→  counts: counts.csv
   193→  metadata: metadata.csv
   194→params:
   195→  grouping_column: Treatment
   196→  n_permutations: 999
   197→```
   198→
   199→**SIMPER vs Indicator Species:**
   200→- SIMPER: Decomposes dissimilarity (abundance differences)
   201→- Indicator Species: Identifies group-specific features (presence/absence + abundance)
   202→
   203→---
   204→
   205→## Compositional Data Analysis (CoDA)
   206→
   207→**When to use:** User mentions &quot;compositional&quot;, &quot;Aitchison&quot;, or data is relative abundances.
   208→
   209→**Pipeline:**
   210→```yaml
   211→# 1. CLR transform
   212→primitive: clr
   213→inputs:
   214→  counts: counts.csv
   215→params:
   216→  pseudocount: 0.5
   217→
   218→# 2. PCA on CLR-transformed data
   219→primitive: pca
   220→inputs:
   221→  counts: counts.csv
   222→params:
   223→  n_components: 2
   224→  scale: true
   225→
   226→# 3. Aitchison distance for beta diversity
   227→primitive: beta_diversity
   228→inputs:
   229→  counts: counts.csv
   230→params:
   231→  metric: aitchison
   232→```
   233→
   234→---
   235→
   236→## Quick Exploration
   237→
   238→**When to use:** User wants a quick overview before deciding on methods.
   239→
   240→```yaml
   241→# Just run diagnose
   242→primitive: diagnose
   243→inputs:
   244→  counts: counts.csv
   245→```
   246→
   247→Report:
   248→- Sample size and feature count
   249→- Sparsity level
   250→- Overdispersion assessment
   251→- Zero-inflation assessment
   252→- Recommended methods
   253→
   254→---
   255→
   256→## Comparison Table
   257→
   258→| Workflow | Normalization | Model | Test | Use Case |
   259→|----------|--------------|-------|------|----------|
   260→| DESeq2 | Median of Ratios | NegBinom GLM | Wald | RNA-seq, moderate samples |
   261→| edgeR | TMM | NegBinom GLM | LRT | RNA-seq, any sample size |
   262→| vegan | None (relative) | Non-parametric | PERMANOVA | Microbiome ecology |
   263→| CoDA | CLR | Euclidean | Standard stats | Compositional data |
   264→
   265→---
   266→
   267→## Notes on Reproducibility
   268→
   269→These workflows match published R package behavior:
   270→- DESeq2: Validated against DESeq2 1.38+ (correlation &gt; 0.95)
   271→- vegan: PERMANOVA/ANOSIM F/R statistics match exactly
   272→- Diversity metrics: Validated against vegan::diversity()
   273→
   274→Using standard workflows enables direct comparison with published results using R packages.
   275→

&lt;system-reminder&gt;
Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
&lt;/system-reminder&gt;
</pre></div><button class="expand-btn">Show more</button></div></div></div></div>
<div class="message assistant" id="msg-2025-12-19T21-56-45-160Z"><div class="message-header"><span class="role-label">Assistant</span><a href="#msg-2025-12-19T21-56-45-160Z" class="timestamp-link"><time datetime="2025-12-19T21:56:45.160Z" data-timestamp="2025-12-19T21:56:45.160Z">2025-12-19T21:56:45.160Z</time></a></div><div class="message-content">
<div class="thinking"><div class="thinking-label">Thinking</div><p>This is excellent! I've found the existing skill infrastructure. Let me analyze what's already in place:</p>
<h2>What exists in <code>.claude/skills/biostack/</code>:</h2>
<ol>
<li><strong>SKILL.md</strong> - Main entry point for the skill</li>
<li>Two modes: Data-driven composition (diagnose-led) and Standard Workflows</li>
<li>Session context via briefing.md/context.md</li>
<li>Lists all primitives and categories</li>
<li>
<p>References other skill files</p>
</li>
<li>
<p><strong>PRIMITIVE_GENERATION.md</strong> - Comprehensive guide for LLM-driven primitive creation</p>
</li>
<li>Detection triggers (when to generate)</li>
<li>5-phase workflow: Specification → Mathematical Foundation → Implementation → Testing → Deployment</li>
<li>CLI commands for primitive workflow (some don't exist yet)</li>
<li>Testing requirements with bioanvil datasets</li>
<li>Validation report template</li>
<li>
<p>File locations reference</p>
</li>
<li>
<p><strong>PRIMITIVES.md</strong> - Complete primitive reference</p>
</li>
<li>All primitives with inputs, outputs, parameters</li>
<li>Examples in YAML format</li>
<li>
<p>Data flow notes</p>
</li>
<li>
<p><strong>INTERPRETATION.md</strong> - Statistical result interpretation guide</p>
</li>
<li>How to explain results to users</li>
<li>
<p>Not relevant to primitive development</p>
</li>
<li>
<p><strong>STANDARD_WORKFLOWS.md</strong> - Canned analysis workflows</p>
</li>
<li>DESeq2, edgeR, vegan-style analyses</li>
<li>Not relevant to primitive development</li>
</ol>
<h2>Key Observations:</h2>
<ol>
<li><strong>PRIMITIVE_GENERATION.md is comprehensive</strong> - It already contains the workflow for LLM-driven primitive development</li>
<li><strong>It references CLI commands that don't exist yet</strong> - <code>bio primitive new</code>, <code>bio primitive validate</code>, <code>bio primitive register</code>, <code>bio primitive test</code></li>
<li><strong>It's separate from CLAUDE.md</strong> - The skill system keeps the main CLAUDE.md lean</li>
<li><strong>The workflow is well-defined</strong> - 5 phases, testing requirements, validation criteria</li>
</ol>
<h2>Reassessment:</h2>
<p>Given this existing skill infrastructure:</p>
<ol>
<li>
<p><strong>CLAUDE.md should remain lean</strong> - The skill system handles the details</p>
</li>
<li>
<p><strong>CLI tooling is secondary</strong> - The skill provides guidance for LLMs directly through documentation</p>
</li>
<li><strong>Workflow adaptation needed:</strong></li>
<li>Current CLI commands are hypothetical</li>
<li>Direct file manipulation patterns are more practical</li>
<li>
<p>Documentation should focus on explicit file editing strategies</p>
</li>
<li>
<p><strong>Immediate focus:</strong></p>
</li>
<li>Modify PRIMITIVE_GENERATION.md to outline precise file modification techniques</li>
<li>Create clear pathways for primitive development without relying on non-existent CLI tools</li>
<li>Ensure LLM can navigate skill infrastructure independently</li>
</ol>
<p>I'll verify the CLAUDE.md reference to confirm skill integration and documentation alignment.</p></div></div></div>
<div class="message assistant" id="msg-2025-12-19T21-56-45-184Z"><div class="message-header"><span class="role-label">Assistant</span><a href="#msg-2025-12-19T21-56-45-184Z" class="timestamp-link"><time datetime="2025-12-19T21:56:45.184Z" data-timestamp="2025-12-19T21:56:45.184Z">2025-12-19T21:56:45.184Z</time></a></div><div class="message-content">
<div class="assistant-text"><p>This is excellent! The skill infrastructure is already quite comprehensive. Let me check if CLAUDE.md references this skill system.</p></div></div></div>
<div class="message assistant" id="msg-2025-12-19T21-56-45-414Z"><div class="message-header"><span class="role-label">Assistant</span><a href="#msg-2025-12-19T21-56-45-414Z" class="timestamp-link"><time datetime="2025-12-19T21:56:45.414Z" data-timestamp="2025-12-19T21:56:45.414Z">2025-12-19T21:56:45.414Z</time></a></div><div class="message-content">
<div class="tool-use" data-tool-id="toolu_01Wm7rd9oN3Wyk2UYrwCK5w1"><div class="tool-header"><span class="tool-icon">⚙</span> Grep</div><div class="truncatable"><div class="truncatable-content"><pre class="json">{
  &#34;pattern&#34;: &#34;skill|PRIMITIVE_GENERATION|\\.claude&#34;,
  &#34;path&#34;: &#34;/Users/scotthandley/Code/biostack/CLAUDE.md&#34;,
  &#34;output_mode&#34;: &#34;content&#34;
}</pre></div><button class="expand-btn">Show more</button></div></div></div></div>
<div class="message tool-reply" id="msg-2025-12-19T21-56-45-776Z"><div class="message-header"><span class="role-label">Tool reply</span><a href="#msg-2025-12-19T21-56-45-776Z" class="timestamp-link"><time datetime="2025-12-19T21:56:45.776Z" data-timestamp="2025-12-19T21:56:45.776Z">2025-12-19T21:56:45.776Z</time></a></div><div class="message-content"><div class="tool-result"><div class="truncatable"><div class="truncatable-content"><pre>115:Detailed guides for Claude Code sessions are in `.claude/skills/biostack/`:
121:| `PRIMITIVE_GENERATION.md` | Creating new primitives on-the-fly |</pre></div><button class="expand-btn">Show more</button></div></div></div></div>
<div class="message assistant" id="msg-2025-12-19T21-56-49-929Z"><div class="message-header"><span class="role-label">Assistant</span><a href="#msg-2025-12-19T21-56-49-929Z" class="timestamp-link"><time datetime="2025-12-19T21:56:49.929Z" data-timestamp="2025-12-19T21:56:49.929Z">2025-12-19T21:56:49.929Z</time></a></div><div class="message-content">
<div class="thinking"><div class="thinking-label">Thinking</div><p>Let me see the full context of what's in CLAUDE.md about the skill system.</p></div></div></div>
<div class="message assistant" id="msg-2025-12-19T21-56-50-549Z"><div class="message-header"><span class="role-label">Assistant</span><a href="#msg-2025-12-19T21-56-50-549Z" class="timestamp-link"><time datetime="2025-12-19T21:56:50.549Z" data-timestamp="2025-12-19T21:56:50.549Z">2025-12-19T21:56:50.549Z</time></a></div><div class="message-content">
<div class="assistant-text"><p>Let me see that section in full.</p></div></div></div>
<div class="message assistant" id="msg-2025-12-19T21-56-51-421Z"><div class="message-header"><span class="role-label">Assistant</span><a href="#msg-2025-12-19T21-56-51-421Z" class="timestamp-link"><time datetime="2025-12-19T21:56:51.421Z" data-timestamp="2025-12-19T21:56:51.421Z">2025-12-19T21:56:51.421Z</time></a></div><div class="message-content">
<div class="tool-use" data-tool-id="toolu_01TBF9s8yJjbRFBvFg8FTAne"><div class="tool-header"><span class="tool-icon">⚙</span> Read</div><div class="truncatable"><div class="truncatable-content"><pre class="json">{
  &#34;file_path&#34;: &#34;/Users/scotthandley/Code/biostack/CLAUDE.md&#34;,
  &#34;offset&#34;: 110,
  &#34;limit&#34;: 30
}</pre></div><button class="expand-btn">Show more</button></div></div></div></div>
<div class="message tool-reply" id="msg-2025-12-19T21-56-51-478Z"><div class="message-header"><span class="role-label">Tool reply</span><a href="#msg-2025-12-19T21-56-51-478Z" class="timestamp-link"><time datetime="2025-12-19T21:56:51.478Z" data-timestamp="2025-12-19T21:56:51.478Z">2025-12-19T21:56:51.478Z</time></a></div><div class="message-content"><div class="tool-result"><div class="truncatable"><div class="truncatable-content"><pre>   110→- Future integration with biostack for direct terminal visualization
   111→- See ggterm repo for development
   112→
   113→## Claude Code Skills
   114→
   115→Detailed guides for Claude Code sessions are in `.claude/skills/biostack/`:
   116→
   117→| Skill | Purpose |
   118→|-------|---------|
   119→| `SKILL.md` | Main usage guide - data-driven composition workflow |
   120→| `PRIMITIVES.md` | Complete primitive reference with parameters |
   121→| `PRIMITIVE_GENERATION.md` | Creating new primitives on-the-fly |
   122→| `STANDARD_WORKFLOWS.md` | DESeq2, edgeR, vegan workflow patterns |
   123→| `INTERPRETATION.md` | How to explain statistical results to users |
   124→
   125→## Related Documentation
   126→
   127→- `docs/ROADMAP.md` - Project roadmap with phases
   128→- `docs/VISUALIZATION_ARCHITECTURE.md` - Visualization system design
   129→- `docs/PRIMITIVE_ARCHITECTURE.md` - Primitive system design
   130→- `bioanvil/definitions/` - Mathematical definitions (source of truth)
   131→

&lt;system-reminder&gt;
Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
&lt;/system-reminder&gt;
</pre></div><button class="expand-btn">Show more</button></div></div></div></div>
<div class="message assistant" id="msg-2025-12-19T21-57-01-417Z"><div class="message-header"><span class="role-label">Assistant</span><a href="#msg-2025-12-19T21-57-01-417Z" class="timestamp-link"><time datetime="2025-12-19T21:57:01.417Z" data-timestamp="2025-12-19T21:57:01.417Z">2025-12-19T21:57:01.417Z</time></a></div><div class="message-content">
<div class="thinking"><div class="thinking-label">Thinking</div><p>Now I have a clear picture. Let me summarize what I've found and provide my reassessment:</p>
<h2>Current State:</h2>
<ol>
<li>
<p><strong>CLAUDE.md is already lean</strong> - It just points to the skills with a table (lines 113-123)</p>
</li>
<li>
<p><strong>PRIMITIVE_GENERATION.md is comprehensive</strong> - It contains:</p>
</li>
<li>Detection triggers for when to generate</li>
<li>5-phase workflow</li>
<li>Testing requirements</li>
<li>File location references</li>
<li>
<p>Example complete workflow</p>
</li>
<li>
<p><strong>The skill references CLI commands that don't exist</strong> - Like <code>bio primitive new</code>, <code>bio primitive validate</code>, <code>bio primitive register</code>, <code>bio primitive test</code></p>
</li>
</ol>
<h2>Reassessment:</h2>
<p>Given this existing infrastructure, my recommendations should change:</p>
<p><strong>Lower Priority:</strong>
- Developer experience CLI tools - The skill can guide the LLM to do direct file operations
- CLAUDE.md updates - It's already lean and points to skills appropriately</p>
<p><strong>Higher Priority:</strong>
1. <strong>Update PRIMITIVE_GENERATION.md</strong> - Replace references to non-existent CLI commands with direct file operations that an LLM can actually execute
2. <strong>Spec infrastructure completion</strong> - Continue what we're doing with TOML specs (params_schema, validation)
3. <strong>Ensure the skill workflow actually works</strong> - The skill describes a workflow, but some pieces may be missing (like <code>bio primitive test</code> referencing bioanvil)</p>
<p>Let me provide this analysis to the user.</p></div></div></div>
<div class="message assistant" id="msg-2025-12-19T21-57-12-122Z"><div class="message-header"><span class="role-label">Assistant</span><a href="#msg-2025-12-19T21-57-12-122Z" class="timestamp-link"><time datetime="2025-12-19T21:57:12.122Z" data-timestamp="2025-12-19T21:57:12.122Z">2025-12-19T21:57:12.122Z</time></a></div><div class="message-content">
<div class="assistant-text"><p>Now I have a complete picture. Here's my reassessment:</p>
<h2>Current State Analysis</h2>
<p><strong>CLAUDE.md is already lean</strong> - it just contains a table pointing to the skills (lines 113-123).</p>
<p><strong>The skill system is comprehensive</strong>:
- <code>PRIMITIVE_GENERATION.md</code> has a full 5-phase workflow for LLM-driven primitive creation
- It references file locations, testing requirements, and validation criteria
- This is exactly what you wanted - context lives in skills, not CLAUDE.md</p>
<p><strong>However, there's a gap</strong>: The skill references CLI commands that don't exist:
- <code>bio primitive new &lt;name&gt;</code> - doesn't exist
- <code>bio primitive validate &lt;name&gt;</code> - doesn't exist<br />
- <code>bio primitive register &lt;name&gt;</code> - doesn't exist
- <code>bio primitive test &lt;name&gt;</code> - doesn't exist</p>
<h2>Reassessed Recommendations</h2>
<p>Given the existing skill infrastructure, my priorities shift:</p>
<table>
<thead>
<tr>
<th>Option</th>
<th>Priority</th>
<th>Reason</th>
</tr>
</thead>
<tbody>
<tr>
<td>CLI tooling for humans</td>
<td><strong>Low</strong></td>
<td>LLMs don't need CLI - they can do direct file operations</td>
</tr>
<tr>
<td>CLAUDE.md updates</td>
<td><strong>Low</strong></td>
<td>Already lean, points to skills correctly</td>
</tr>
<tr>
<td><strong>Update PRIMITIVE_GENERATION.md</strong></td>
<td><strong>High</strong></td>
<td>Replace non-existent CLI commands with actual file operations</td>
</tr>
<tr>
<td>Spec validation</td>
<td><strong>Medium</strong></td>
<td>Useful but skill can guide manual validation</td>
</tr>
</tbody>
</table>
<h2>Recommended Next Step</h2>
<p>Update <code>PRIMITIVE_GENERATION.md</code> to replace hypothetical CLI commands with actual LLM-executable workflows. For example, instead of:</p>
<pre><code class="language-bash">bio primitive new indicator_species
</code></pre>
<p>Use:</p>
<pre><code>1. Create TOML spec at bioforge/specs/&lt;name&gt;.toml
2. Create implementation at bioforge/src/primitive/builtins/&lt;name&gt;.rs
3. Add `mod &lt;name&gt;;` to builtins/mod.rs
4. Register in PrimitiveRegistry::with_builtins()
</code></pre>
<p>This makes the skill immediately actionable for LLMs without requiring CLI development.</p>
<p>Shall I update <code>PRIMITIVE_GENERATION.md</code> to reflect actual LLM-executable workflows?</p></div></div></div>
<div class="message user" id="msg-2025-12-19T22-01-09-865Z"><div class="message-header"><span class="role-label">User</span><a href="#msg-2025-12-19T22-01-09-865Z" class="timestamp-link"><time datetime="2025-12-19T22:01:09.865Z" data-timestamp="2025-12-19T22:01:09.865Z">2025-12-19T22:01:09.865Z</time></a></div><div class="message-content">
<div class="user-content"><p>yes update PRIMITIVE_GENERATION.md</p></div></div></div>
<div class="message assistant" id="msg-2025-12-19T22-01-15-673Z"><div class="message-header"><span class="role-label">Assistant</span><a href="#msg-2025-12-19T22-01-15-673Z" class="timestamp-link"><time datetime="2025-12-19T22:01:15.673Z" data-timestamp="2025-12-19T22:01:15.673Z">2025-12-19T22:01:15.673Z</time></a></div><div class="message-content">
<div class="thinking"><div class="thinking-label">Thinking</div><p>The user wants me to update PRIMITIVE_GENERATION.md to replace hypothetical CLI commands with actual LLM-executable workflows. Let me read the file again and make the necessary updates.</p>
<p>Key changes needed:
1. Replace <code>bio primitive new &lt;name&gt;</code> with actual file creation steps
2. Replace <code>bio primitive validate &lt;name&gt;</code> with actual validation steps
3. Replace <code>bio primitive register &lt;name&gt;</code> with actual registration steps
4. Replace <code>bio primitive test &lt;name&gt;</code> with actual test commands
5. Make the workflow more concrete and executable by an LLM</p>
<p>Let me read the full file first to understand the structure.</p></div></div></div>
<div class="message assistant" id="msg-2025-12-19T22-01-17-255Z"><div class="message-header"><span class="role-label">Assistant</span><a href="#msg-2025-12-19T22-01-17-255Z" class="timestamp-link"><time datetime="2025-12-19T22:01:17.255Z" data-timestamp="2025-12-19T22:01:17.255Z">2025-12-19T22:01:17.255Z</time></a></div><div class="message-content">
<div class="todo-list" data-tool-id="toolu_01LtudHgXhXS85314tBtw6Do"><div class="todo-header"><span class="todo-header-icon">☰</span> Task List</div><ul class="todo-items"><li class="todo-item todo-in-progress"><span class="todo-icon">→</span><span class="todo-content">Update PRIMITIVE_GENERATION.md with LLM-executable workflows</span></li></ul></div></div></div>
<div class="message assistant" id="msg-2025-12-19T22-01-18-335Z"><div class="message-header"><span class="role-label">Assistant</span><a href="#msg-2025-12-19T22-01-18-335Z" class="timestamp-link"><time datetime="2025-12-19T22:01:18.335Z" data-timestamp="2025-12-19T22:01:18.335Z">2025-12-19T22:01:18.335Z</time></a></div><div class="message-content">
<div class="tool-use" data-tool-id="toolu_01KZ3tWJKZDq5jonYnmhSuU8"><div class="tool-header"><span class="tool-icon">⚙</span> Read</div><div class="truncatable"><div class="truncatable-content"><pre class="json">{
  &#34;file_path&#34;: &#34;/Users/scotthandley/Code/biostack/.claude/skills/biostack/PRIMITIVE_GENERATION.md&#34;
}</pre></div><button class="expand-btn">Show more</button></div></div></div></div>
<div class="message tool-reply" id="msg-2025-12-19T22-01-18-373Z"><div class="message-header"><span class="role-label">Tool reply</span><a href="#msg-2025-12-19T22-01-18-373Z" class="timestamp-link"><time datetime="2025-12-19T22:01:18.373Z" data-timestamp="2025-12-19T22:01:18.373Z">2025-12-19T22:01:18.373Z</time></a></div><div class="message-content"><div class="tool-result"><div class="truncatable"><div class="truncatable-content"><pre>Todos have been modified successfully. Ensure that you continue to use the todo list to track your progress. Please proceed with the current tasks if applicable</pre></div><button class="expand-btn">Show more</button></div></div></div></div>
<div class="message tool-reply" id="msg-2025-12-19T22-01-18-414Z"><div class="message-header"><span class="role-label">Tool reply</span><a href="#msg-2025-12-19T22-01-18-414Z" class="timestamp-link"><time datetime="2025-12-19T22:01:18.414Z" data-timestamp="2025-12-19T22:01:18.414Z">2025-12-19T22:01:18.414Z</time></a></div><div class="message-content"><div class="tool-result"><div class="truncatable"><div class="truncatable-content"><pre>     1→# Auto-Generating New Primitives
     2→
     3→When a user needs an analysis that doesn&#x27;t exist as a primitive, you can create it on-the-fly. This workflow ensures new primitives are properly implemented, tested, and validated.
     4→
     5→---
     6→
     7→## When to Generate a New Primitive
     8→
     9→### Detection Triggers
    10→
    11→1. **User requests an analysis not in PRIMITIVES.md**:
    12→   - &quot;Calculate Aitchison distance&quot; (if not available)
    13→   - &quot;Run indicator species analysis&quot; (if not available)
    14→   - &quot;Perform MRPP&quot; (Multi-Response Permutation Procedure)
    15→
    16→2. **Diagnose recommends unavailable method**:
    17→   ```json
    18→   &quot;recommendations&quot;: {
    19→     &quot;additional_analyses&quot;: [&quot;indicator_species&quot;, &quot;simper&quot;]
    20→   }
    21→   ```
    22→
    23→3. **User explicitly asks for a custom primitive**:
    24→   - &quot;Can you add a primitive for...&quot;
    25→   - &quot;I need a method that...&quot;
    26→
    27→### Before Generating
    28→
    29→1. **Check if primitive exists**: `bio primitives | grep &lt;name&gt;`
    30→2. **Check spec exists**: `bio primitive list`
    31→3. **Search bioanvil definitions**: Check `bioanvil/definitions/` for existing math
    32→
    33→---
    34→
    35→## Generation Workflow
    36→
    37→### Phase 1: Specification
    38→
    39→**1.1 Write the TOML spec**
    40→
    41→```bash
    42→# Create spec file
    43→touch bioforge/specs/&lt;primitive_name&gt;.toml
    44→```
    45→
    46→Spec template:
    47→```toml
    48→[primitive]
    49→name = &quot;&lt;primitive_name&gt;&quot;
    50→category = &quot;&lt;category&gt;&quot;  # test, filter, normalize, transform, diversity, etc.
    51→description = &quot;&lt;one-line description&gt;&quot;
    52→
    53→[params.&lt;param_name&gt;]
    54→type = &quot;&lt;string|integer|float|boolean|enum&gt;&quot;
    55→required = &lt;true|false&gt;
    56→description = &quot;&lt;description&gt;&quot;
    57→# Optional: default, min, max, variants
    58→
    59→[[inputs]]
    60→slot = &quot;&lt;slot_name&gt;&quot;  # counts, metadata, distance_matrix, etc.
    61→required = true
    62→description = &quot;&lt;why needed&gt;&quot;
    63→
    64→[[outputs]]
    65→slot = &quot;&lt;slot_name&gt;&quot;
    66→description = &quot;&lt;what it contains&gt;&quot;
    67→
    68→[algorithm]
    69→formula = &quot;&quot;&quot;
    70→&lt;mathematical formula&gt;
    71→&quot;&quot;&quot;
    72→notes = &quot;&lt;implementation considerations&gt;&quot;
    73→
    74→[validation]
    75→r_package = &quot;&lt;reference R package&gt;&quot;
    76→r_function = &quot;&lt;reference function&gt;&quot;
    77→```
    78→
    79→**1.2 Validate the spec**
    80→
    81→```bash
    82→bio primitive validate &lt;primitive_name&gt;
    83→```
    84→
    85→### Phase 2: Mathematical Foundation
    86→
    87→**2.1 Write definition document**
    88→
    89→Create `bioanvil/definitions/&lt;primitive_name&gt;.md`:
    90→
    91→```markdown
    92→# &lt;Primitive Name&gt;: Mathematical Definition
    93→
    94→## Reference
    95→&lt;citation&gt;
    96→
    97→## Formula
    98→&lt;core formula with explanation&gt;
    99→
   100→## Worked Example
   101→&lt;step-by-step calculation with numbers&gt;
   102→
   103→## Properties
   104→- &lt;key property 1&gt;
   105→- &lt;key property 2&gt;
   106→
   107→## Test Values
   108→&lt;expected outputs for known inputs&gt;
   109→```
   110→
   111→**2.2 Check existing definitions**
   112→
   113→```bash
   114→ls bioanvil/definitions/
   115→# alpha_diversity.md, beta_diversity.md, statistical_tests.md, indicator_species.md
   116→```
   117→
   118→### Phase 3: Implementation
   119→
   120→**3.1 Generate scaffold**
   121→
   122→```bash
   123→bio primitive new &lt;primitive_name&gt;
   124→```
   125→
   126→This creates:
   127→- `bioforge/src/primitive/builtins/&lt;primitive_name&gt;.rs` (implementation stub)
   128→- Updates to `bioanvil/definitions/&lt;primitive_name&gt;.md` (if not exists)
   129→- `bioanvil/reference/r/&lt;primitive_name&gt;.R` (R reference script)
   130→
   131→**3.2 Implement the algorithm**
   132→
   133→Open the generated `.rs` file and replace `todo!()` with actual implementation:
   134→
   135→```rust
   136→fn execute(&amp;self, ctx: &amp;mut ExecutionContext) -&gt; Result&lt;()&gt; {
   137→    // 1. Get inputs
   138→    let counts = ctx.get::&lt;CountMatrix&gt;(DataSlot::Counts)
   139→        .ok_or_else(|| BioforgeError::MissingData(&quot;counts&quot;.to_string()))?;
   140→
   141→    // 2. Get parameters
   142→    let threshold: f64 = ctx.param_or(&quot;threshold&quot;, 0.05);
   143→
   144→    // 3. Implement algorithm
   145→    // ... your implementation here ...
   146→
   147→    // 4. Set outputs
   148→    ctx.set(DataSlot::PValues, p_values);
   149→    ctx.set(DataSlot::TestStatistics, statistics);
   150→
   151→    Ok(())
   152→}
   153→```
   154→
   155→**3.3 Register the primitive**
   156→
   157→```bash
   158→bio primitive register &lt;primitive_name&gt;
   159→```
   160→
   161→This automatically:
   162→- Adds `mod &lt;primitive_name&gt;;` to `builtins/mod.rs`
   163→- Adds `pub use &lt;primitive_name&gt;::*;` to `builtins/mod.rs`
   164→- Adds `registry.register(&lt;PrimitiveName&gt;);` to `registry.rs`
   165→
   166→### Phase 4: Testing &amp; Validation
   167→
   168→**CRITICAL**: This phase ensures user confidence. All tests must pass.
   169→
   170→**4.1 Run unit tests**
   171→
   172→```bash
   173→cargo test -p bioforge &lt;primitive_name&gt;
   174→```
   175→
   176→Expected tests:
   177→- `test_&lt;name&gt;_identity` - name, category correct
   178→- `test_&lt;name&gt;_schema` - parameters defined
   179→- `test_&lt;name&gt;_inputs_outputs` - slots defined
   180→
   181→**4.2 Run bioanvil validation**
   182→
   183→```bash
   184→bio primitive test &lt;primitive_name&gt;
   185→```
   186→
   187→This runs the primitive against bioanvil datasets and produces a validation report:
   188→
   189→```
   190→=== Validation Report: indicator_species ===
   191→
   192→Dataset: two_group_strong
   193→  Sensitivity: 0.925 (37/40 true positives detected)
   194→  Specificity: 0.983 (59/60 true negatives correct)
   195→  Precision: 0.974 (37/38 detections were correct)
   196→  F1 Score: 0.949
   197→  FALSE POSITIVE RATE: 0.017 (1/60)
   198→
   199→Dataset: null (false positive calibration)
   200→  Features detected as significant: 3/100
   201→  Expected at alpha=0.05: ~5
   202→  CALIBRATION: PASS (FPR = 0.03)
   203→
   204→Dataset: sparse
   205→  Execution: PASS (handled zeros correctly)
   206→
   207→Reference comparison (R/indicspecies):
   208→  IndVal correlation: r = 0.998
   209→  P-value correlation: r = 0.995
   210→  Max discrepancy: 0.002
   211→
   212→OVERALL: PASS (4/4 tests passed)
   213→```
   214→
   215→**4.3 Test against worked examples**
   216→
   217→Verify implementation matches the worked example in the definition:
   218→
   219→```rust
   220→#[test]
   221→fn test_against_definition_example() {
   222→    // From bioanvil/definitions/indicator_species.md
   223→    let counts = vec![
   224→        vec![100, 90, 10, 5],   // feat_1
   225→        vec![5, 8, 80, 95],     // feat_2
   226→        vec![50, 55, 45, 52],   // feat_3
   227→    ];
   228→    let groups = vec![&quot;A&quot;, &quot;A&quot;, &quot;B&quot;, &quot;B&quot;];
   229→
   230→    let result = compute_indval(&amp;counts, &amp;groups);
   231→
   232→    // Expected from definition
   233→    assert!((result[0].indval - 92.7).abs() &lt; 1.0);
   234→}
   235→```
   236→
   237→### Phase 5: Deployment
   238→
   239→**5.1 Compile and restart**
   240→
   241→```bash
   242→cargo build --release -p bioengine &amp;&amp; bio restart
   243→```
   244→
   245→**5.2 Verify availability**
   246→
   247→```bash
   248→bio schema &lt;primitive_name&gt;
   249→```
   250→
   251→**5.3 Test in session**
   252→
   253→```yaml
   254→primitive: &lt;primitive_name&gt;
   255→inputs:
   256→  counts: counts.csv
   257→  metadata: metadata.csv
   258→params:
   259→  &lt;param&gt;: &lt;value&gt;
   260→```
   261→
   262→---
   263→
   264→## Testing Requirements
   265→
   266→### Required Test Coverage
   267→
   268→| Test Type | Dataset | Purpose | Pass Criteria |
   269→|-----------|---------|---------|---------------|
   270→| **Correctness** | two_group_strong | Detect true effects | Sensitivity &gt; 0.80 |
   271→| **Specificity** | two_group_strong | Avoid false positives | FDR &lt; 0.10 |
   272→| **Calibration** | null | FPR at nominal level | FPR within 2x of alpha |
   273→| **Edge cases** | sparse | Handle zeros | No crashes, reasonable output |
   274→| **Multi-group** | multi_group | Handle &gt;2 groups | Correct for all pairs |
   275→| **Reference** | any | Match R implementation | r &gt; 0.95 for statistics |
   276→
   277→### Test Against Ground Truth
   278→
   279→Bioanvil datasets have known true effects:
   280→
   281→```rust
   282→use bioanvil::{Dataset, GroundTruth};
   283→
   284→let dataset = Dataset::load(&quot;two_group_strong&quot;)?;
   285→let truth = GroundTruth::load(&quot;two_group_strong&quot;)?;
   286→
   287→// Run your primitive
   288→let results = my_primitive(&amp;dataset);
   289→
   290→// Evaluate
   291→let significant: HashSet&lt;_&gt; = results
   292→    .iter()
   293→    .filter(|r| r.p_value &lt; 0.05)
   294→    .map(|r| r.feature_id.clone())
   295→    .collect();
   296→
   297→let metrics = truth.evaluate(&amp;significant);
   298→
   299→assert!(metrics.sensitivity &gt; 0.80, &quot;Must detect most true effects&quot;);
   300→assert!(metrics.fdr() &lt; 0.10, &quot;False discovery rate too high&quot;);
   301→```
   302→
   303→### False Positive Calibration (CRITICAL)
   304→
   305→The `null` dataset has NO true effects. Use it to verify your primitive doesn&#x27;t over-call:
   306→
   307→```rust
   308→let truth = GroundTruth::load(&quot;null&quot;)?;
   309→assert_eq!(truth.true_positives.len(), 0);  // No true effects
   310→
   311→// Run primitive at alpha = 0.05
   312→let significant = run_primitive_at_alpha(&amp;dataset, 0.05);
   313→
   314→// Should be approximately 5% false positives
   315→let fpr = significant.len() as f64 / 100.0;
   316→assert!(fpr &lt; 0.10, &quot;FPR too high: {}&quot;, fpr);
   317→```
   318→
   319→---
   320→
   321→## Documentation for User Confidence
   322→
   323→After validation passes, generate a test report that users can review.
   324→
   325→### Validation Report Template
   326→
   327→Create `bioanvil/reports/&lt;primitive_name&gt;_validation.md`:
   328→
   329→```markdown
   330→# Validation Report: &lt;primitive_name&gt;
   331→
   332→Generated: &lt;timestamp&gt;
   333→BioStack version: &lt;version&gt;
   334→
   335→## Summary
   336→
   337→| Metric | Value | Threshold | Status |
   338→|--------|-------|-----------|--------|
   339→| Sensitivity | 0.925 | &gt; 0.80 | PASS |
   340→| Specificity | 0.983 | &gt; 0.90 | PASS |
   341→| F1 Score | 0.949 | &gt; 0.85 | PASS |
   342→| FPR Calibration | 0.03 | &lt; 0.10 | PASS |
   343→| R Correlation | 0.998 | &gt; 0.95 | PASS |
   344→
   345→## Datasets Tested
   346→
   347→### two_group_strong
   348→- 100 features, 20 samples
   349→- 40 truly differential features
   350→- Result: 37/40 detected, 1 false positive
   351→
   352→### null
   353→- 100 features, 20 samples
   354→- NO true effects
   355→- Result: 3 features called (FPR = 0.03)
   356→
   357→### sparse
   358→- 100 features, 20 samples
   359→- ~67% zeros
   360→- Result: Completed without error
   361→
   362→## Reference Comparison
   363→
   364→Compared to R package `&lt;package&gt;`::&lt;function&gt;()
   365→
   366→| Statistic | Correlation | Max Difference |
   367→|-----------|-------------|----------------|
   368→| Test statistic | 0.998 | 0.15 |
   369→| P-value | 0.995 | 0.003 |
   370→
   371→## Mathematical Verification
   372→
   373→Tested against worked example from definition:
   374→- Expected IndVal: 92.7%
   375→- Computed IndVal: 92.68%
   376→- MATCH
   377→
   378→## Conclusion
   379→
   380→This primitive is validated and ready for production use.
   381→```
   382→
   383→---
   384→
   385→## Common Issues &amp; Solutions
   386→
   387→### Issue: Low Sensitivity
   388→
   389→**Symptoms**: Missing true positives
   390→**Causes**:
   391→- Threshold too stringent
   392→- Algorithm error
   393→- Wrong null hypothesis
   394→
   395→**Solution**: Check against worked example, verify formula implementation
   396→
   397→### Issue: High False Positive Rate
   398→
   399→**Symptoms**: FPR &gt;&gt; alpha on null dataset
   400→**Causes**:
   401→- P-value calculation error
   402→- Permutation insufficient
   403→- Edge case handling
   404→
   405→**Solution**: Increase permutations, check permutation procedure
   406→
   407→### Issue: Differs from R Reference
   408→
   409→**Symptoms**: Statistics don&#x27;t match R package
   410→**Causes**:
   411→- Different algorithm variant
   412→- Tie handling differs
   413→- Numerical precision
   414→
   415→**Solution**: Document the difference, verify both are mathematically correct
   416→
   417→---
   418→
   419→## Quick Reference
   420→
   421→### Commands
   422→
   423→```bash
   424→# Check existing primitives
   425→bio primitives
   426→
   427→# List available specs
   428→bio primitive list
   429→
   430→# Validate spec
   431→bio primitive validate &lt;name&gt;
   432→
   433→# Generate scaffold
   434→bio primitive new &lt;name&gt;
   435→
   436→# Register primitive
   437→bio primitive register &lt;name&gt;
   438→
   439→# Run validation tests
   440→bio primitive test &lt;name&gt;
   441→
   442→# Compile and restart
   443→cargo build --release -p bioengine &amp;&amp; bio restart
   444→
   445→# Verify working
   446→bio schema &lt;name&gt;
   447→```
   448→
   449→### File Locations
   450→
   451→| File | Purpose |
   452→|------|---------|
   453→| `bioforge/specs/&lt;name&gt;.toml` | Primitive specification |
   454→| `bioforge/src/primitive/builtins/&lt;name&gt;.rs` | Implementation |
   455→| `bioanvil/definitions/&lt;name&gt;.md` | Mathematical definition |
   456→| `bioanvil/reference/r/&lt;name&gt;.R` | R reference script |
   457→| `bioanvil/reports/&lt;name&gt;_validation.md` | Validation report |
   458→
   459→### Bioanvil Datasets
   460→
   461→| Dataset | Samples | Features | True Effects | Use Case |
   462→|---------|---------|----------|--------------|----------|
   463→| two_group_strong | 20 | 100 | 40 | Basic correctness |
   464→| multi_group | 30 | 100 | 30 | Multi-group tests |
   465→| continuous | 20 | 100 | 30 | Continuous covariates |
   466→| sparse | 20 | 100 | 30 | High sparsity |
   467→| null | 20 | 100 | 0 | FPR calibration |
   468→
   469→---
   470→
   471→## Example: Complete Workflow
   472→
   473→User asks: &quot;Can you calculate indicator species for my microbiome data?&quot;
   474→
   475→### Step 1: Check availability
   476→```bash
   477→bio primitives | grep indicator
   478→# No output - doesn&#x27;t exist
   479→```
   480→
   481→### Step 2: Create spec
   482→Write `bioforge/specs/indicator_species.toml` with parameters, inputs, outputs.
   483→
   484→### Step 3: Write definition
   485→Create `bioanvil/definitions/indicator_species.md` with IndVal formula and worked example.
   486→
   487→### Step 4: Generate and implement
   488→```bash
   489→bio primitive new indicator_species
   490→# Edit bioforge/src/primitive/builtins/indicator_species.rs
   491→```
   492→
   493→### Step 5: Register
   494→```bash
   495→bio primitive register indicator_species
   496→```
   497→
   498→### Step 6: Test
   499→```bash
   500→cargo test -p bioforge indicator_species
   501→bio primitive test indicator_species
   502→```
   503→
   504→### Step 7: Deploy
   505→```bash
   506→cargo build --release -p bioengine &amp;&amp; bio restart
   507→```
   508→
   509→### Step 8: Use
   510→```yaml
   511→primitive: indicator_species
   512→inputs:
   513→  counts: counts.csv
   514→  metadata: metadata.csv
   515→params:
   516→  grouping_column: Treatment
   517→  n_permutations: 999
   518→```
   519→
   520→This workflow ensures new primitives are properly implemented, tested, and validated before use.
   521→

&lt;system-reminder&gt;
Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
&lt;/system-reminder&gt;
</pre></div><button class="expand-btn">Show more</button></div></div></div></div>
<div class="message assistant" id="msg-2025-12-19T22-01-24-075Z"><div class="message-header"><span class="role-label">Assistant</span><a href="#msg-2025-12-19T22-01-24-075Z" class="timestamp-link"><time datetime="2025-12-19T22:01:24.075Z" data-timestamp="2025-12-19T22:01:24.075Z">2025-12-19T22:01:24.075Z</time></a></div><div class="message-content">
<div class="thinking"><div class="thinking-label">Thinking</div><p>Now I need to rewrite this file to replace all the hypothetical CLI commands with actual LLM-executable workflows. The key changes:</p>
<ol>
<li>Replace <code>bio primitive new &lt;name&gt;</code> with actual file creation steps</li>
<li>Replace <code>bio primitive validate &lt;name&gt;</code> with manual validation steps</li>
<li>Replace <code>bio primitive register &lt;name&gt;</code> with actual file edit instructions</li>
<li>Replace <code>bio primitive test &lt;name&gt;</code> with cargo test commands</li>
<li>Replace <code>bio primitive list</code> with actual file system checks</li>
<li>Make the workflow concrete and executable</li>
</ol>
<p>Let me also check what existing primitives look like for reference patterns.</p></div></div></div>
<div class="message assistant" id="msg-2025-12-19T22-01-24-831Z"><div class="message-header"><span class="role-label">Assistant</span><a href="#msg-2025-12-19T22-01-24-831Z" class="timestamp-link"><time datetime="2025-12-19T22:01:24.831Z" data-timestamp="2025-12-19T22:01:24.831Z">2025-12-19T22:01:24.831Z</time></a></div><div class="message-content">
<div class="assistant-text"><p>Let me check an existing primitive implementation to reference the correct patterns.</p></div></div></div>
<div class="message assistant" id="msg-2025-12-19T22-01-25-579Z"><div class="message-header"><span class="role-label">Assistant</span><a href="#msg-2025-12-19T22-01-25-579Z" class="timestamp-link"><time datetime="2025-12-19T22:01:25.579Z" data-timestamp="2025-12-19T22:01:25.579Z">2025-12-19T22:01:25.579Z</time></a></div><div class="message-content">
<div class="tool-use" data-tool-id="toolu_0131U2ARFftYe5mDVAVxZzRa"><div class="tool-header"><span class="tool-icon">⚙</span> Read</div><div class="truncatable"><div class="truncatable-content"><pre class="json">{
  &#34;file_path&#34;: &#34;/Users/scotthandley/Code/biostack/bioforge/src/primitive/builtins/mod.rs&#34;
}</pre></div><button class="expand-btn">Show more</button></div></div></div></div>
<div class="message assistant" id="msg-2025-12-19T22-01-26-714Z"><div class="message-header"><span class="role-label">Assistant</span><a href="#msg-2025-12-19T22-01-26-714Z" class="timestamp-link"><time datetime="2025-12-19T22:01:26.714Z" data-timestamp="2025-12-19T22:01:26.714Z">2025-12-19T22:01:26.714Z</time></a></div><div class="message-content">
<div class="tool-use" data-tool-id="toolu_01Tm6r23nYcJEzEHjwxpp4nR"><div class="tool-header"><span class="tool-icon">⚙</span> Read</div><div class="truncatable"><div class="truncatable-content"><pre class="json">{
  &#34;file_path&#34;: &#34;/Users/scotthandley/Code/biostack/bioforge/src/primitive/builtins/mrpp.rs&#34;,
  &#34;limit&#34;: 100
}</pre></div><button class="expand-btn">Show more</button></div></div></div></div>
<div class="message tool-reply" id="msg-2025-12-19T22-01-26-843Z"><div class="message-header"><span class="role-label">Tool reply</span><a href="#msg-2025-12-19T22-01-26-843Z" class="timestamp-link"><time datetime="2025-12-19T22:01:26.843Z" data-timestamp="2025-12-19T22:01:26.843Z">2025-12-19T22:01:26.843Z</time></a></div><div class="message-content"><div class="tool-result"><div class="truncatable"><div class="truncatable-content"><pre>     1→//! Built-in primitive implementations.
     2→//!
     3→//! This module contains primitive wrappers for existing bioforge functionality.
     4→//! Each primitive wraps an existing function or method and exposes it through
     5→//! the unified [`Primitive`] trait.
     6→//!
     7→//! # Categories
     8→//!
     9→//! - **Filters**: `filter_prevalence`, `filter_abundance`, `filter_variance`
    10→//! - **Normalization**: `tmm`, `median_of_ratios`, `upper_quartile`
    11→//! - **Transforms**: `clr`, `vst`, `rlog`, `log`, `zscore`
    12→//! - **Diagnostics**: `diagnose`
    13→//! - **Models**: `fit_glm`
    14→//! - **Tests**: `wald`, `lrt`, `score`, `permutation`, `bootstrap`
    15→//! - **Corrections**: `benjamini_hochberg`, `bonferroni`, `holm`, `qvalue`, `local_fdr`
    16→//! - **Diversity**: `alpha_diversity`, `beta_diversity`, `permanova`, `anosim`
    17→//! - **Ordination**: `pca`, `pcoa`, `nmds`
    18→//! - **Visualization**: `scatter_plot`, `query_plot`, `annotate_plot`, `filter_plot`, `restyle_plot`
    19→
    20→mod correct;
    21→mod dbrda;
    22→mod diagnose;
    23→mod diversity;
    24→mod filter;
    25→mod indicator_species;
    26→#[cfg(test)]
    27→mod macro_test;
    28→mod model;
    29→mod mrpp;
    30→mod normalize;
    31→mod ordination;
    32→mod simper;
    33→mod test;
    34→mod transform;
    35→mod viz;
    36→
    37→pub use correct::{
    38→    BenjaminiHochbergCorrection, BonferroniCorrection, HolmCorrection, LocalFdrCorrection,
    39→    QValueCorrection,
    40→};
    41→pub use dbrda::DbRda;
    42→pub use diagnose::Diagnose;
    43→pub use diversity::{
    44→    AlphaDiversityPrimitive, AnosimPrimitive, BetaDiversityPrimitive, PermanovaPrimitive,
    45→};
    46→pub use filter::{FilterAbundance, FilterPrevalence, FilterVariance};
    47→pub use indicator_species::IndicatorSpecies;
    48→pub use mrpp::Mrpp;
    49→pub use simper::Simper;
    50→pub use model::FitGlmPrimitive;
    51→pub use normalize::{MedianOfRatiosNormalize, TmmNormalize, UpperQuartileNormalize};
    52→pub use ordination::{NmdsOrdination, PcaOrdination, PcoaOrdination};
    53→pub use test::{
    54→    BootstrapTestPrimitive, LrtTestPrimitive, PermutationTestPrimitive, ScoreTestPrimitive,
    55→    WaldTestPrimitive,
    56→};
    57→pub use transform::{ClrTransform, LogTransform, RlogTransform, VstTransform, ZscoreTransform};
    58→pub use viz::{
    59→    AnnotatePlotPrimitive, FilterPlotPrimitive, QueryPlotPrimitive, RestylePlotPrimitive,
    60→    ScatterPlotPrimitive,
    61→};
    62→

&lt;system-reminder&gt;
Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
&lt;/system-reminder&gt;
</pre></div><button class="expand-btn">Show more</button></div></div></div></div>
<div class="message tool-reply" id="msg-2025-12-19T22-01-26-844Z"><div class="message-header"><span class="role-label">Tool reply</span><a href="#msg-2025-12-19T22-01-26-844Z" class="timestamp-link"><time datetime="2025-12-19T22:01:26.844Z" data-timestamp="2025-12-19T22:01:26.844Z">2025-12-19T22:01:26.844Z</time></a></div><div class="message-content"><div class="tool-result"><div class="truncatable"><div class="truncatable-content"><pre>     1→//! MRPP (Multi-Response Permutation Procedure) primitive.
     2→//!
     3→//! Tests whether groups differ significantly using within-group distance analysis.
     4→//!
     5→//! Reference: Mielke, P.W. &amp; Berry, K.J. (2001). Permutation Methods: A Distance
     6→//! Function Approach. Springer.
     7→
     8→use crate::data::SampleMetadata;
     9→use crate::diversity::DistanceMatrix;
    10→use crate::primitive::{DataSlot, ExecutionContext};
    11→use crate::Result;
    12→use serde::{Deserialize, Serialize};
    13→use std::collections::HashMap;
    14→
    15→/// Result of an MRPP test.
    16→#[derive(Debug, Clone, Serialize, Deserialize)]
    17→pub struct MrppResult {
    18→    /// Observed weighted mean within-group distance (delta).
    19→    pub observed_delta: f64,
    20→
    21→    /// Expected delta under null hypothesis.
    22→    pub expected_delta: f64,
    23→
    24→    /// A statistic (chance-corrected within-group agreement).
    25→    /// A = 1 - (observed_delta / expected_delta)
    26→    pub a_statistic: f64,
    27→
    28→    /// P-value from permutation test.
    29→    pub p_value: f64,
    30→
    31→    /// Number of groups.
    32→    pub n_groups: usize,
    33→
    34→    /// Total number of samples.
    35→    pub n_samples: usize,
    36→
    37→    /// Number of permutations performed.
    38→    pub n_permutations: usize,
    39→
    40→    /// Weight type used.
    41→    pub weight_type: String,
    42→}
    43→
    44→impl MrppResult {
    45→    /// Check if significant at given alpha level.
    46→    pub fn is_significant(&amp;self, alpha: f64) -&gt; bool {
    47→        self.p_value &lt; alpha
    48→    }
    49→
    50→    /// Interpret A statistic.
    51→    pub fn interpret_a(&amp;self) -&gt; &amp;&#x27;static str {
    52→        let a = self.a_statistic;
    53→        if a &gt; 0.3 {
    54→            &quot;Fairly strong group separation&quot;
    55→        } else if a &gt; 0.1 {
    56→            &quot;Weak to moderate group separation&quot;
    57→        } else if a &gt; 0.0 {
    58→            &quot;Weak or no group separation&quot;
    59→        } else {
    60→            &quot;More heterogeneous than expected by chance&quot;
    61→        }
    62→    }
    63→}
    64→
    65→/// Simple linear congruential generator for permutation shuffling.
    66→struct SimpleRng {
    67→    state: u64,
    68→}
    69→
    70→impl SimpleRng {
    71→    fn new(seed: u64) -&gt; Self {
    72→        Self {
    73→            state: seed.wrapping_add(1),
    74→        }
    75→    }
    76→
    77→    fn from_entropy() -&gt; Self {
    78→        use std::time::{SystemTime, UNIX_EPOCH};
    79→        let seed = SystemTime::now()
    80→            .duration_since(UNIX_EPOCH)
    81→            .map(|d| d.as_nanos() as u64)
    82→            .unwrap_or(42);
    83→        Self::new(seed)
    84→    }
    85→
    86→    fn next_u64(&amp;mut self) -&gt; u64 {
    87→        self.state = self
    88→            .state
    89→            .wrapping_mul(6364136223846793005)
    90→            .wrapping_add(1);
    91→        self.state
    92→    }
    93→
    94→    fn next_usize(&amp;mut self, max: usize) -&gt; usize {
    95→        (self.next_u64() as usize) % max
    96→    }
    97→
    98→    /// Fisher-Yates shuffle.
    99→    fn shuffle&lt;T&gt;(&amp;mut self, slice: &amp;mut [T]) {
   100→        for i in (1..slice.len()).rev() {

&lt;system-reminder&gt;
Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
&lt;/system-reminder&gt;
</pre></div><button class="expand-btn">Show more</button></div></div></div></div>
<div class="message assistant" id="msg-2025-12-19T22-01-34-471Z"><div class="message-header"><span class="role-label">Assistant</span><a href="#msg-2025-12-19T22-01-34-471Z" class="timestamp-link"><time datetime="2025-12-19T22:01:34.471Z" data-timestamp="2025-12-19T22:01:34.471Z">2025-12-19T22:01:34.471Z</time></a></div><div class="message-content">
<div class="thinking"><div class="thinking-label">Thinking</div><p>Now I have a good understanding of the patterns. Let me also check how primitives are registered in registry.rs to see the exact pattern.</p></div></div></div>
<div class="message assistant" id="msg-2025-12-19T22-01-35-220Z"><div class="message-header"><span class="role-label">Assistant</span><a href="#msg-2025-12-19T22-01-35-220Z" class="timestamp-link"><time datetime="2025-12-19T22:01:35.220Z" data-timestamp="2025-12-19T22:01:35.220Z">2025-12-19T22:01:35.220Z</time></a></div><div class="message-content">
<div class="assistant-text"><p>Now I have a good picture of the patterns. Let me write the updated PRIMITIVE_GENERATION.md with LLM-executable workflows.</p></div></div></div>
<div class="message assistant" id="msg-2025-12-19T22-03-00-040Z"><div class="message-header"><span class="role-label">Assistant</span><a href="#msg-2025-12-19T22-03-00-040Z" class="timestamp-link"><time datetime="2025-12-19T22:03:00.040Z" data-timestamp="2025-12-19T22:03:00.040Z">2025-12-19T22:03:00.040Z</time></a></div><div class="message-content"><div class="file-tool write-tool" data-tool-id="toolu_0133r2wLtteTTzjrYXHSPBgo">
<div class="file-tool-header write-header"><span class="file-tool-icon">📝</span> Write <span class="file-tool-path">PRIMITIVE_GENERATION.md</span></div>
<div class="file-tool-fullpath">/Users/scotthandley/Code/biostack/.claude/skills/biostack/PRIMITIVE_GENERATION.md</div>
<div class="truncatable"><div class="truncatable-content"><pre class="file-content"># Auto-Generating New Primitives

When a user needs an analysis that doesn&#39;t exist as a primitive, you can create it on-the-fly. This workflow ensures new primitives are properly implemented, tested, and validated.

---

## When to Generate a New Primitive

### Detection Triggers

1. **User requests an analysis not in PRIMITIVES.md**:
   - &#34;Calculate Aitchison distance&#34; (if not available)
   - &#34;Run indicator species analysis&#34; (if not available)
   - &#34;Perform MRPP&#34; (Multi-Response Permutation Procedure)

2. **Diagnose recommends unavailable method**:
   ```json
   &#34;recommendations&#34;: {
     &#34;additional_analyses&#34;: [&#34;indicator_species&#34;, &#34;simper&#34;]
   }
   ```

3. **User explicitly asks for a custom primitive**:
   - &#34;Can you add a primitive for...&#34;
   - &#34;I need a method that...&#34;

### Before Generating

1. **Check if primitive exists**: Search `bioforge/src/primitive/builtins/` for the name
2. **Check spec exists**: Look in `bioforge/specs/` for `&lt;name&gt;.toml`
3. **Search bioanvil definitions**: Check `bioanvil/definitions/` for existing math

---

## Generation Workflow

### Phase 1: Specification

**1.1 Write the TOML spec**

Create `bioforge/specs/&lt;primitive_name&gt;.toml`:

```toml
# =============================================================================
# Primitive Specification: &lt;primitive_name&gt;
# =============================================================================
# &lt;One-line description&gt;
# =============================================================================

[primitive]
name = &#34;&lt;primitive_name&gt;&#34;
category = &#34;&lt;category&gt;&#34;  # test, filter, normalize, transform, diversity, visualize
description = &#34;&lt;one-line description&gt;&#34;

# =============================================================================
# Parameters
# =============================================================================

[params.&lt;param_name&gt;]
type = &#34;&lt;string|integer|float|boolean&gt;&#34;
required = &lt;true|false&gt;
description = &#34;&lt;description&gt;&#34;
# Optional fields:
# default = &lt;value&gt;
# min = &lt;number&gt;
# max = &lt;number&gt;
# allowed_values = [&#34;option1&#34;, &#34;option2&#34;]  # For enum types

# =============================================================================
# Inputs
# =============================================================================

[inputs.&lt;input_name&gt;]
slot = &#34;&lt;SlotName&gt;&#34;  # Counts, Metadata, DistanceMatrix, PlotSpec, etc.
required = true
description = &#34;&lt;why needed&gt;&#34;

# =============================================================================
# Outputs
# =============================================================================

[outputs.&lt;output_name&gt;]
slot = &#34;&lt;SlotName&gt;&#34;
description = &#34;&lt;what it contains&gt;&#34;

# =============================================================================
# Algorithm
# =============================================================================

[algorithm]
method = &#34;&lt;algorithm name&gt;&#34;
formula = &#34;&#34;&#34;
&lt;mathematical formula or description&gt;
&#34;&#34;&#34;

# =============================================================================
# Provenance
# =============================================================================

[provenance]
fields = [&#34;field1&#34;, &#34;field2&#34;]
summary_template = &#34;&lt;primitive_name&gt;: {field1}, {field2}&#34;

# =============================================================================
# LLM Context
# =============================================================================

[llm]
suggested_when = &#34;&lt;when to use this primitive&gt;&#34;
typical_predecessors = [&#34;primitive1&#34;, &#34;primitive2&#34;]
typical_successors = [&#34;primitive3&#34;, &#34;primitive4&#34;]
```

**1.2 Validate the spec manually**

Check that:
- All required fields are present
- Parameter types are valid: `string`, `integer`, `float`, `boolean`
- Input/output slots exist in `bioforge/src/primitive/requirements.rs` (DataSlot enum)
- Category matches `bioforge/src/primitive/category.rs` (Category enum)

### Phase 2: Mathematical Foundation

**2.1 Check existing definitions**

Look in `bioanvil/definitions/` for related methods:
- `alpha_diversity.md` - diversity metrics
- `beta_diversity.md` - distance metrics
- `statistical_tests.md` - general statistical testing
- `indicator_species.md` - indicator value analysis
- `permanova.md` - PERMANOVA test

**2.2 Write definition document (if needed)**

Create `bioanvil/definitions/&lt;primitive_name&gt;.md`:

```markdown
# &lt;Primitive Name&gt;: Mathematical Definition

## Reference
&lt;citation - author, year, paper/book&gt;

## Formula
&lt;core formula with explanation&gt;

## Worked Example
&lt;step-by-step calculation with actual numbers&gt;

Given:
- Input data: [values]
- Parameters: [values]

Step 1: ...
Step 2: ...

Result: [expected output]

## Properties
- &lt;key property 1&gt;
- &lt;key property 2&gt;

## Test Values
Input: [specific test input]
Expected output: [specific expected output]
```

### Phase 3: Implementation

**3.1 Create the implementation file**

Create `bioforge/src/primitive/builtins/&lt;primitive_name&gt;.rs`:

```rust
//! &lt;Primitive Name&gt; primitive.
//!
//! &lt;Description of what it does&gt;
//!
//! Reference: &lt;citation&gt;

use crate::primitive::{DataSlot, ExecutionContext};
use crate::Result;
use serde::{Deserialize, Serialize};

/// Result of &lt;primitive_name&gt;.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct &lt;PrimitiveName&gt;Result {
    // Add result fields
    pub statistic: f64,
    pub p_value: f64,
}

/// Compute &lt;primitive_name&gt;.
pub fn compute_&lt;primitive_name&gt;(/* inputs */) -&gt; Result&lt;&lt;PrimitiveName&gt;Result&gt; {
    // Implement the algorithm here
    todo!(&#34;Implement algorithm&#34;)
}

// =============================================================================
// Primitive wrapper (uses macro)
// =============================================================================

bioforge_macros::primitive! {
    name: &#34;&lt;primitive_name&gt;&#34;,
    category: &lt;Category&gt;,  // Filter, Normalize, Transform, Test, Correct, Diversity, Visualize
    description: &#34;&lt;description&gt;&#34;,

    fn execute(ctx) {
        // 1. Get inputs
        let data = ctx.get::&lt;DataType&gt;(DataSlot::SlotName)
            .ok_or_else(|| crate::BioforgeError::MissingData(&#34;data&#34;.to_string()))?;

        // 2. Get parameters
        let param: f64 = ctx.param_or(&#34;param_name&#34;, 0.05);

        // 3. Run algorithm
        let result = compute_&lt;primitive_name&gt;(/* args */)?;

        // 4. Set outputs
        ctx.set(DataSlot::OutputSlot, result);

        Ok(())
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_&lt;primitive_name&gt;_basic() {
        // Test with known values from definition
    }
}
```

**3.2 Register the primitive**

Edit `bioforge/src/primitive/builtins/mod.rs`:

1. Add the module declaration:
```rust
mod &lt;primitive_name&gt;;
```

2. Add the public export:
```rust
pub use &lt;primitive_name&gt;::&lt;PrimitiveName&gt;;
```

Edit `bioforge/src/primitive/registry.rs` in `with_builtins()`:

```rust
// In the appropriate category section
registry.register(&lt;PrimitiveName&gt;);
```

### Phase 4: Testing &amp; Validation

**CRITICAL**: This phase ensures user confidence. All tests must pass.

**4.1 Run unit tests**

```bash
cargo test -p bioforge &lt;primitive_name&gt;
```

The primitive should have tests for:
- Basic correctness with known values
- Edge cases (empty input, single sample, etc.)
- Parameter validation

**4.2 Test against worked example**

Verify implementation matches the worked example in the definition:

```rust
#[test]
fn test_against_definition_example() {
    // From bioanvil/definitions/&lt;primitive_name&gt;.md
    let input = /* test input from definition */;
    let expected = /* expected output from definition */;

    let result = compute_&lt;primitive_name&gt;(input);

    assert!((result.statistic - expected).abs() &lt; 0.01);
}
```

**4.3 Run bioanvil validation (when applicable)**

For statistical tests, validate against bioanvil datasets:

```rust
use bioanvil::{Dataset, GroundTruth};

#[test]
fn test_sensitivity_specificity() {
    let dataset = Dataset::load(&#34;two_group_strong&#34;).unwrap();
    let truth = GroundTruth::load(&#34;two_group_strong&#34;).unwrap();

    // Run primitive
    let results = /* run primitive on dataset */;

    // Evaluate
    let significant: HashSet&lt;_&gt; = results
        .iter()
        .filter(|r| r.p_value &lt; 0.05)
        .map(|r| r.feature_id.clone())
        .collect();

    let metrics = truth.evaluate(&amp;significant);

    assert!(metrics.sensitivity &gt; 0.80, &#34;Must detect most true effects&#34;);
    assert!(metrics.fdr() &lt; 0.10, &#34;False discovery rate too high&#34;);
}
```

### Phase 5: Deployment

**5.1 Compile and verify**

```bash
cargo build -p bioforge
cargo test -p bioforge
```

**5.2 Restart daemon if running**

```bash
bio stop &amp;&amp; bio start
```

**5.3 Verify availability**

```bash
bio schema &lt;primitive_name&gt;
```

This should show the primitive&#39;s parameters from the TOML spec.

**5.4 Test in session**

Write a command file to `.biostack/commands/pending/`:

```yaml
primitive: &lt;primitive_name&gt;
inputs:
  data: data.csv
  metadata: metadata.csv
params:
  param_name: value
```

---

## Testing Requirements

### Required Test Coverage

| Test Type | Dataset | Purpose | Pass Criteria |
|-----------|---------|---------|---------------|
| **Correctness** | two_group_strong | Detect true effects | Sensitivity &gt; 0.80 |
| **Specificity** | two_group_strong | Avoid false positives | FDR &lt; 0.10 |
| **Calibration** | null | FPR at nominal level | FPR within 2x of alpha |
| **Edge cases** | sparse | Handle zeros | No crashes, reasonable output |
| **Multi-group** | multi_group | Handle &gt;2 groups | Correct for all pairs |
| **Reference** | any | Match R implementation | r &gt; 0.95 for statistics |

### False Positive Calibration (CRITICAL)

The `null` dataset has NO true effects. Use it to verify your primitive doesn&#39;t over-call:

```rust
#[test]
fn test_false_positive_calibration() {
    let dataset = Dataset::load(&#34;null&#34;).unwrap();

    // Run primitive at alpha = 0.05
    let significant = run_primitive_at_alpha(&amp;dataset, 0.05);

    // Should be approximately 5% false positives
    let fpr = significant.len() as f64 / 100.0;
    assert!(fpr &lt; 0.10, &#34;FPR too high: {}&#34;, fpr);
}
```

---

## Common Issues &amp; Solutions

### Issue: Low Sensitivity

**Symptoms**: Missing true positives
**Causes**:
- Threshold too stringent
- Algorithm error
- Wrong null hypothesis

**Solution**: Check against worked example, verify formula implementation

### Issue: High False Positive Rate

**Symptoms**: FPR &gt;&gt; alpha on null dataset
**Causes**:
- P-value calculation error
- Permutation insufficient
- Edge case handling

**Solution**: Increase permutations, check permutation procedure

### Issue: Differs from R Reference

**Symptoms**: Statistics don&#39;t match R package
**Causes**:
- Different algorithm variant
- Tie handling differs
- Numerical precision

**Solution**: Document the difference, verify both are mathematically correct

---

## File Locations

| File | Purpose |
|------|---------|
| `bioforge/specs/&lt;name&gt;.toml` | Primitive specification (params, inputs, outputs) |
| `bioforge/src/primitive/builtins/&lt;name&gt;.rs` | Implementation |
| `bioforge/src/primitive/builtins/mod.rs` | Module registration |
| `bioforge/src/primitive/registry.rs` | Primitive registry (with_builtins) |
| `bioanvil/definitions/&lt;name&gt;.md` | Mathematical definition |

### Key Source Files to Reference

| File | What to Learn |
|------|---------------|
| `bioforge/src/primitive/builtins/mrpp.rs` | Complete primitive with permutation test |
| `bioforge/src/primitive/builtins/indicator_species.rs` | Multi-group analysis primitive |
| `bioforge/src/primitive/builtins/diversity.rs` | Beta diversity + PERMANOVA |
| `bioforge/src/primitive/context.rs` | ExecutionContext API (get, set, param_or) |
| `bioforge/src/primitive/requirements.rs` | DataSlot enum (available slots) |
| `bioforge/src/primitive/category.rs` | Category enum |

### Bioanvil Datasets

| Dataset | Samples | Features | True Effects | Use Case |
|---------|---------|----------|--------------|----------|
| two_group_strong | 20 | 100 | 40 | Basic correctness |
| multi_group | 30 | 100 | 30 | Multi-group tests |
| continuous | 20 | 100 | 30 | Continuous covariates |
| sparse | 20 | 100 | 30 | High sparsity |
| null | 20 | 100 | 0 | FPR calibration |

---

## Example: Complete Workflow

User asks: &#34;Can you calculate indicator species for my microbiome data?&#34;

### Step 1: Check availability

Search for existing implementation:
- Look in `bioforge/src/primitive/builtins/` for `indicator_species.rs`
- Look in `bioforge/specs/` for `indicator_species.toml`

### Step 2: Create spec

Write `bioforge/specs/indicator_species.toml` with parameters, inputs, outputs following the template above.

### Step 3: Write definition

Create `bioanvil/definitions/indicator_species.md` with IndVal formula and worked example.

### Step 4: Implement

Create `bioforge/src/primitive/builtins/indicator_species.rs` with:
- Result struct
- Algorithm implementation
- Primitive macro wrapper

### Step 5: Register

Edit `bioforge/src/primitive/builtins/mod.rs`:
```rust
mod indicator_species;
pub use indicator_species::IndicatorSpecies;
```

Edit `bioforge/src/primitive/registry.rs`:
```rust
registry.register(IndicatorSpecies);
```

### Step 6: Test

```bash
cargo test -p bioforge indicator_species
```

### Step 7: Deploy

```bash
cargo build -p bioforge &amp;&amp; cargo build -p bioengine
bio stop &amp;&amp; bio start  # If daemon running
```

### Step 8: Verify

```bash
bio schema indicator_species
```

### Step 9: Use

Write to `.biostack/commands/pending/test_indicator.yaml`:
```yaml
primitive: indicator_species
inputs:
  counts: counts.csv
  metadata: metadata.csv
params:
  grouping_column: Treatment
  n_permutations: 999
```

This workflow ensures new primitives are properly implemented, tested, and validated before use.
</pre></div><button class="expand-btn">Show more</button></div>
</div></div></div>
<div class="message tool-reply" id="msg-2025-12-19T22-03-00-093Z"><div class="message-header"><span class="role-label">Tool reply</span><a href="#msg-2025-12-19T22-03-00-093Z" class="timestamp-link"><time datetime="2025-12-19T22:03:00.093Z" data-timestamp="2025-12-19T22:03:00.093Z">2025-12-19T22:03:00.093Z</time></a></div><div class="message-content"><div class="tool-result"><div class="truncatable"><div class="truncatable-content"><pre>The file /Users/scotthandley/Code/biostack/.claude/skills/biostack/PRIMITIVE_GENERATION.md has been updated. Here&#x27;s the result of running `cat -n` on a snippet of the edited file:
     1→# Auto-Generating New Primitives
     2→
     3→When a user needs an analysis that doesn&#x27;t exist as a primitive, you can create it on-the-fly. This workflow ensures new primitives are properly implemented, tested, and validated.
     4→
     5→---
     6→
     7→## When to Generate a New Primitive
     8→
     9→### Detection Triggers
    10→
    11→1. **User requests an analysis not in PRIMITIVES.md**:
    12→   - &quot;Calculate Aitchison distance&quot; (if not available)
    13→   - &quot;Run indicator species analysis&quot; (if not available)
    14→   - &quot;Perform MRPP&quot; (Multi-Response Permutation Procedure)
    15→
    16→2. **Diagnose recommends unavailable method**:
    17→   ```json
    18→   &quot;recommendations&quot;: {
    19→     &quot;additional_analyses&quot;: [&quot;indicator_species&quot;, &quot;simper&quot;]
    20→   }
    21→   ```
    22→
    23→3. **User explicitly asks for a custom primitive**:
    24→   - &quot;Can you add a primitive for...&quot;
    25→   - &quot;I need a method that...&quot;
    26→
    27→### Before Generating
    28→
    29→1. **Check if primitive exists**: Search `bioforge/src/primitive/builtins/` for the name
    30→2. **Check spec exists**: Look in `bioforge/specs/` for `&lt;name&gt;.toml`
    31→3. **Search bioanvil definitions**: Check `bioanvil/definitions/` for existing math
    32→
    33→---
    34→
    35→## Generation Workflow
    36→
    37→### Phase 1: Specification
    38→
    39→**1.1 Write the TOML spec**
    40→
    41→Create `bioforge/specs/&lt;primitive_name&gt;.toml`:
    42→
    43→```toml
    44→# =============================================================================
    45→# Primitive Specification: &lt;primitive_name&gt;
    46→# =============================================================================
    47→# &lt;One-line description&gt;
    48→# =============================================================================
    49→
    50→[primitive]
    51→name = &quot;&lt;primitive_name&gt;&quot;
    52→category = &quot;&lt;category&gt;&quot;  # test, filter, normalize, transform, diversity, visualize
    53→description = &quot;&lt;one-line description&gt;&quot;
    54→
    55→# =============================================================================
    56→# Parameters
    57→# =============================================================================
    58→
    59→[params.&lt;param_name&gt;]
    60→type = &quot;&lt;string|integer|float|boolean&gt;&quot;
    61→required = &lt;true|false&gt;
    62→description = &quot;&lt;description&gt;&quot;
    63→# Optional fields:
    64→# default = &lt;value&gt;
    65→# min = &lt;number&gt;
    66→# max = &lt;number&gt;
    67→# allowed_values = [&quot;option1&quot;, &quot;option2&quot;]  # For enum types
    68→
    69→# =============================================================================
    70→# Inputs
    71→# =============================================================================
    72→
    73→[inputs.&lt;input_name&gt;]
    74→slot = &quot;&lt;SlotName&gt;&quot;  # Counts, Metadata, DistanceMatrix, PlotSpec, etc.
    75→required = true
    76→description = &quot;&lt;why needed&gt;&quot;
    77→
    78→# =============================================================================
    79→# Outputs
    80→# =============================================================================
    81→
    82→[outputs.&lt;output_name&gt;]
    83→slot = &quot;&lt;SlotName&gt;&quot;
    84→description = &quot;&lt;what it contains&gt;&quot;
    85→
    86→# =============================================================================
    87→# Algorithm
    88→# =============================================================================
    89→
    90→[algorithm]
    91→method = &quot;&lt;algorithm name&gt;&quot;
    92→formula = &quot;&quot;&quot;
    93→&lt;mathematical formula or description&gt;
    94→&quot;&quot;&quot;
    95→
    96→# =============================================================================
    97→# Provenance
    98→# =============================================================================
    99→
   100→[provenance]
   101→fields = [&quot;field1&quot;, &quot;field2&quot;]
   102→summary_template = &quot;&lt;primitive_name&gt;: {field1}, {field2}&quot;
   103→
   104→# =============================================================================
   105→# LLM Context
   106→# =============================================================================
   107→
   108→[llm]
   109→suggested_when = &quot;&lt;when to use this primitive&gt;&quot;
   110→typical_predecessors = [&quot;primitive1&quot;, &quot;primitive2&quot;]
   111→typical_successors = [&quot;primitive3&quot;, &quot;primitive4&quot;]
   112→```
   113→
   114→**1.2 Validate the spec manually**
   115→
   116→Check that:
   117→- All required fields are present
   118→- Parameter types are valid: `string`, `integer`, `float`, `boolean`
   119→- Input/output slots exist in `bioforge/src/primitive/requirements.rs` (DataSlot enum)
   120→- Category matches `bioforge/src/primitive/category.rs` (Category enum)
   121→
   122→### Phase 2: Mathematical Foundation
   123→
   124→**2.1 Check existing definitions**
   125→
   126→Look in `bioanvil/definitions/` for related methods:
   127→- `alpha_diversity.md` - diversity metrics
   128→- `beta_diversity.md` - distance metrics
   129→- `statistical_tests.md` - general statistical testing
   130→- `indicator_species.md` - indicator value analysis
   131→- `permanova.md` - PERMANOVA test
   132→
   133→**2.2 Write definition document (if needed)**
   134→
   135→Create `bioanvil/definitions/&lt;primitive_name&gt;.md`:
   136→
   137→```markdown
   138→# &lt;Primitive Name&gt;: Mathematical Definition
   139→
   140→## Reference
   141→&lt;citation - author, year, paper/book&gt;
   142→
   143→## Formula
   144→&lt;core formula with explanation&gt;
   145→
   146→## Worked Example
   147→&lt;step-by-step calculation with actual numbers&gt;
   148→
   149→Given:
   150→- Input data: [values]
   151→- Parameters: [values]
   152→
   153→Step 1: ...
   154→Step 2: ...
   155→
   156→Result: [expected output]
   157→
   158→## Properties
   159→- &lt;key property 1&gt;
   160→- &lt;key property 2&gt;
   161→
   162→## Test Values
   163→Input: [specific test input]
   164→Expected output: [specific expected output]
   165→```
   166→
   167→### Phase 3: Implementation
   168→
   169→**3.1 Create the implementation file**
   170→
   171→Create `bioforge/src/primitive/builtins/&lt;primitive_name&gt;.rs`:
   172→
   173→```rust
   174→//! &lt;Primitive Name&gt; primitive.
   175→//!
   176→//! &lt;Description of what it does&gt;
   177→//!
   178→//! Reference: &lt;citation&gt;
   179→
   180→use crate::primitive::{DataSlot, ExecutionContext};
   181→use crate::Result;
   182→use serde::{Deserialize, Serialize};
   183→
   184→/// Result of &lt;primitive_name&gt;.
   185→#[derive(Debug, Clone, Serialize, Deserialize)]
   186→pub struct &lt;PrimitiveName&gt;Result {
   187→    // Add result fields
   188→    pub statistic: f64,
   189→    pub p_value: f64,
   190→}
   191→
   192→/// Compute &lt;primitive_name&gt;.
   193→pub fn compute_&lt;primitive_name&gt;(/* inputs */) -&gt; Result&lt;&lt;PrimitiveName&gt;Result&gt; {
   194→    // Implement the algorithm here
   195→    todo!(&quot;Implement algorithm&quot;)
   196→}
   197→
   198→// =============================================================================
   199→// Primitive wrapper (uses macro)
   200→// =============================================================================
   201→
   202→bioforge_macros::primitive! {
   203→    name: &quot;&lt;primitive_name&gt;&quot;,
   204→    category: &lt;Category&gt;,  // Filter, Normalize, Transform, Test, Correct, Diversity, Visualize
   205→    description: &quot;&lt;description&gt;&quot;,
   206→
   207→    fn execute(ctx) {
   208→        // 1. Get inputs
   209→        let data = ctx.get::&lt;DataType&gt;(DataSlot::SlotName)
   210→            .ok_or_else(|| crate::BioforgeError::MissingData(&quot;data&quot;.to_string()))?;
   211→
   212→        // 2. Get parameters
   213→        let param: f64 = ctx.param_or(&quot;param_name&quot;, 0.05);
   214→
   215→        // 3. Run algorithm
   216→        let result = compute_&lt;primitive_name&gt;(/* args */)?;
   217→
   218→        // 4. Set outputs
   219→        ctx.set(DataSlot::OutputSlot, result);
   220→
   221→        Ok(())
   222→    }
   223→}
   224→
   225→#[cfg(test)]
   226→mod tests {
   227→    use super::*;
   228→
   229→    #[test]
   230→    fn test_&lt;primitive_name&gt;_basic() {
   231→        // Test with known values from definition
   232→    }
   233→}
   234→```
   235→
   236→**3.2 Register the primitive**
   237→
   238→Edit `bioforge/src/primitive/builtins/mod.rs`:
   239→
   240→1. Add the module declaration:
   241→```rust
   242→mod &lt;primitive_name&gt;;
   243→```
   244→
   245→2. Add the public export:
   246→```rust
   247→pub use &lt;primitive_name&gt;::&lt;PrimitiveName&gt;;
   248→```
   249→
   250→Edit `bioforge/src/primitive/registry.rs` in `with_builtins()`:
   251→
   252→```rust
   253→// In the appropriate category section
   254→registry.register(&lt;PrimitiveName&gt;);
   255→```
   256→
   257→### Phase 4: Testing &amp; Validation
   258→
   259→**CRITICAL**: This phase ensures user confidence. All tests must pass.
   260→
   261→**4.1 Run unit tests**
   262→
   263→```bash
   264→cargo test -p bioforge &lt;primitive_name&gt;
   265→```
   266→
   267→The primitive should have tests for:
   268→- Basic correctness with known values
   269→- Edge cases (empty input, single sample, etc.)
   270→- Parameter validation
   271→
   272→**4.2 Test against worked example**
   273→
   274→Verify implementation matches the worked example in the definition:
   275→
   276→```rust
   277→#[test]
   278→fn test_against_definition_example() {
   279→    // From bioanvil/definitions/&lt;primitive_name&gt;.md
   280→    let input = /* test input from definition */;
   281→    let expected = /* expected output from definition */;
   282→
   283→    let result = compute_&lt;primitive_name&gt;(input);
   284→
   285→    assert!((result.statistic - expected).abs() &lt; 0.01);
   286→}
   287→```
   288→
   289→**4.3 Run bioanvil validation (when applicable)**
   290→
   291→For statistical tests, validate against bioanvil datasets:
   292→
   293→```rust
   294→use bioanvil::{Dataset, GroundTruth};
   295→
   296→#[test]
   297→fn test_sensitivity_specificity() {
   298→    let dataset = Dataset::load(&quot;two_group_strong&quot;).unwrap();
   299→    let truth = GroundTruth::load(&quot;two_group_strong&quot;).unwrap();
   300→
   301→    // Run primitive
   302→    let results = /* run primitive on dataset */;
   303→
   304→    // Evaluate
   305→    let significant: HashSet&lt;_&gt; = results
   306→        .iter()
   307→        .filter(|r| r.p_value &lt; 0.05)
   308→        .map(|r| r.feature_id.clone())
   309→        .collect();
   310→
   311→    let metrics = truth.evaluate(&amp;significant);
   312→
   313→    assert!(metrics.sensitivity &gt; 0.80, &quot;Must detect most true effects&quot;);
   314→    assert!(metrics.fdr() &lt; 0.10, &quot;False discovery rate too high&quot;);
   315→}
   316→```
   317→
   318→### Phase 5: Deployment
   319→
   320→**5.1 Compile and verify**
   321→
   322→```bash
   323→cargo build -p bioforge
   324→cargo test -p bioforge
   325→```
   326→
   327→**5.2 Restart daemon if running**
   328→
   329→```bash
   330→bio stop &amp;&amp; bio start
   331→```
   332→
   333→**5.3 Verify availability**
   334→
   335→```bash
   336→bio schema &lt;primitive_name&gt;
   337→```
   338→
   339→This should show the primitive&#x27;s parameters from the TOML spec.
   340→
   341→**5.4 Test in session**
   342→
   343→Write a command file to `.biostack/commands/pending/`:
   344→
   345→```yaml
   346→primitive: &lt;primitive_name&gt;
   347→inputs:
   348→  data: data.csv
   349→  metadata: metadata.csv
   350→params:
   351→  param_name: value
   352→```
   353→
   354→---
   355→
   356→## Testing Requirements
   357→
   358→### Required Test Coverage
   359→
   360→| Test Type | Dataset | Purpose | Pass Criteria |
   361→|-----------|---------|---------|---------------|
   362→| **Correctness** | two_group_strong | Detect true effects | Sensitivity &gt; 0.80 |
   363→| **Specificity** | two_group_strong | Avoid false positives | FDR &lt; 0.10 |
   364→| **Calibration** | null | FPR at nominal level | FPR within 2x of alpha |
   365→| **Edge cases** | sparse | Handle zeros | No crashes, reasonable output |
   366→| **Multi-group** | multi_group | Handle &gt;2 groups | Correct for all pairs |
   367→| **Reference** | any | Match R implementation | r &gt; 0.95 for statistics |
   368→
   369→### False Positive Calibration (CRITICAL)
   370→
   371→The `null` dataset has NO true effects. Use it to verify your primitive doesn&#x27;t over-call:
   372→
   373→```rust
   374→#[test]
   375→fn test_false_positive_calibration() {
   376→    let dataset = Dataset::load(&quot;null&quot;).unwrap();
   377→
   378→    // Run primitive at alpha = 0.05
   379→    let significant = run_primitive_at_alpha(&amp;dataset, 0.05);
   380→
   381→    // Should be approximately 5% false positives
   382→    let fpr = significant.len() as f64 / 100.0;
   383→    assert!(fpr &lt; 0.10, &quot;FPR too high: {}&quot;, fpr);
   384→}
   385→```
   386→
   387→---
   388→
   389→## Common Issues &amp; Solutions
   390→
   391→### Issue: Low Sensitivity
   392→
   393→**Symptoms**: Missing true positives
   394→**Causes**:
   395→- Threshold too stringent
   396→- Algorithm error
   397→- Wrong null hypothesis
   398→
   399→**Solution**: Check against worked example, verify formula implementation
   400→
   401→### Issue: High False Positive Rate
   402→
   403→**Symptoms**: FPR &gt;&gt; alpha on null dataset
   404→**Causes**:
   405→- P-value calculation error
   406→- Permutation insufficient
   407→- Edge case handling
   408→
   409→**Solution**: Increase permutations, check permutation procedure
   410→
   411→### Issue: Differs from R Reference
   412→
   413→**Symptoms**: Statistics don&#x27;t match R package
   414→**Causes**:
   415→- Different algorithm variant
   416→- Tie handling differs
   417→- Numerical precision
   418→
   419→**Solution**: Document the difference, verify both are mathematically correct
   420→
   421→---
   422→
   423→## File Locations
   424→
   425→| File | Purpose |
   426→|------|---------|
   427→| `bioforge/specs/&lt;name&gt;.toml` | Primitive specification (params, inputs, outputs) |
   428→| `bioforge/src/primitive/builtins/&lt;name&gt;.rs` | Implementation |
   429→| `bioforge/src/primitive/builtins/mod.rs` | Module registration |
   430→| `bioforge/src/primitive/registry.rs` | Primitive registry (with_builtins) |
   431→| `bioanvil/definitions/&lt;name&gt;.md` | Mathematical definition |
   432→
   433→### Key Source Files to Reference
   434→
   435→| File | What to Learn |
   436→|------|---------------|
   437→| `bioforge/src/primitive/builtins/mrpp.rs` | Complete primitive with permutation test |
   438→| `bioforge/src/primitive/builtins/indicator_species.rs` | Multi-group analysis primitive |
   439→| `bioforge/src/primitive/builtins/diversity.rs` | Beta diversity + PERMANOVA |
   440→| `bioforge/src/primitive/context.rs` | ExecutionContext API (get, set, param_or) |
   441→| `bioforge/src/primitive/requirements.rs` | DataSlot enum (available slots) |
   442→| `bioforge/src/primitive/category.rs` | Category enum |
   443→
   444→### Bioanvil Datasets
   445→
   446→| Dataset | Samples | Features | True Effects | Use Case |
   447→|---------|---------|----------|--------------|----------|
   448→| two_group_strong | 20 | 100 | 40 | Basic correctness |
   449→| multi_group | 30 | 100 | 30 | Multi-group tests |
   450→| continuous | 20 | 100 | 30 | Continuous covariates |
   451→| sparse | 20 | 100 | 30 | High sparsity |
   452→| null | 20 | 100 | 0 | FPR calibration |
   453→
   454→---
   455→
   456→## Example: Complete Workflow
   457→
   458→User asks: &quot;Can you calculate indicator species for my microbiome data?&quot;
   459→
   460→### Step 1: Check availability
   461→
   462→Search for existing implementation:
   463→- Look in `bioforge/src/primitive/builtins/` for `indicator_species.rs`
   464→- Look in `bioforge/specs/` for `indicator_species.toml`
   465→
   466→### Step 2: Create spec
   467→
   468→Write `bioforge/specs/indicator_species.toml` with parameters, inputs, outputs following the template above.
   469→
   470→### Step 3: Write definition
   471→
   472→Create `bioanvil/definitions/indicator_species.md` with IndVal formula and worked example.
   473→
   474→### Step 4: Implement
   475→
   476→Create `bioforge/src/primitive/builtins/indicator_species.rs` with:
   477→- Result struct
   478→- Algorithm implementation
   479→- Primitive macro wrapper
   480→
   481→### Step 5: Register
   482→
   483→Edit `bioforge/src/primitive/builtins/mod.rs`:
   484→```rust
   485→mod indicator_species;
   486→pub use indicator_species::IndicatorSpecies;
   487→```
   488→
   489→Edit `bioforge/src/primitive/registry.rs`:
   490→```rust
   491→registry.register(IndicatorSpecies);
   492→```
   493→
   494→### Step 6: Test
   495→
   496→```bash
   497→cargo test -p bioforge indicator_species
   498→```
   499→
   500→### Step 7: Deploy
   501→
   502→```bash
   503→cargo build -p bioforge &amp;&amp; cargo build -p bioengine
   504→bio stop &amp;&amp; bio start  # If daemon running
   505→```
   506→
   507→### Step 8: Verify
   508→
   509→```bash
   510→bio schema indicator_species
   511→```
   512→
   513→### Step 9: Use
   514→
   515→Write to `.biostack/commands/pending/test_indicator.yaml`:
   516→```yaml
   517→primitive: indicator_species
   518→inputs:
   519→  counts: counts.csv
   520→  metadata: metadata.csv
   521→params:
   522→  grouping_column: Treatment
   523→  n_permutations: 999
   524→```
   525→
   526→This workflow ensures new primitives are properly implemented, tested, and validated before use.
   527→</pre></div><button class="expand-btn">Show more</button></div></div></div></div>
<div class="message assistant" id="msg-2025-12-19T22-03-03-609Z"><div class="message-header"><span class="role-label">Assistant</span><a href="#msg-2025-12-19T22-03-03-609Z" class="timestamp-link"><time datetime="2025-12-19T22:03:03.609Z" data-timestamp="2025-12-19T22:03:03.609Z">2025-12-19T22:03:03.609Z</time></a></div><div class="message-content">
<div class="thinking"><div class="thinking-label">Thinking</div><p>I've updated PRIMITIVE_GENERATION.md. Now let me mark the todo as complete and summarize the changes.</p></div></div></div>
<div class="message assistant" id="msg-2025-12-19T22-03-04-779Z"><div class="message-header"><span class="role-label">Assistant</span><a href="#msg-2025-12-19T22-03-04-779Z" class="timestamp-link"><time datetime="2025-12-19T22:03:04.779Z" data-timestamp="2025-12-19T22:03:04.779Z">2025-12-19T22:03:04.779Z</time></a></div><div class="message-content">
<div class="todo-list" data-tool-id="toolu_01MnCQuEQeCCapxnDmvh8SAn"><div class="todo-header"><span class="todo-header-icon">☰</span> Task List</div><ul class="todo-items"><li class="todo-item todo-completed"><span class="todo-icon">✓</span><span class="todo-content">Update PRIMITIVE_GENERATION.md with LLM-executable workflows</span></li></ul></div></div></div>
<div class="message tool-reply" id="msg-2025-12-19T22-03-04-827Z"><div class="message-header"><span class="role-label">Tool reply</span><a href="#msg-2025-12-19T22-03-04-827Z" class="timestamp-link"><time datetime="2025-12-19T22:03:04.827Z" data-timestamp="2025-12-19T22:03:04.827Z">2025-12-19T22:03:04.827Z</time></a></div><div class="message-content"><div class="tool-result"><div class="truncatable"><div class="truncatable-content"><pre>Todos have been modified successfully. Ensure that you continue to use the todo list to track your progress. Please proceed with the current tasks if applicable</pre></div><button class="expand-btn">Show more</button></div></div></div></div>
<div class="message assistant" id="msg-2025-12-19T22-03-08-786Z"><div class="message-header"><span class="role-label">Assistant</span><a href="#msg-2025-12-19T22-03-08-786Z" class="timestamp-link"><time datetime="2025-12-19T22:03:08.786Z" data-timestamp="2025-12-19T22:03:08.786Z">2025-12-19T22:03:08.786Z</time></a></div><div class="message-content">
<div class="thinking"><div class="thinking-label">Thinking</div><p>Done. Let me summarize the changes I made to the file.</p></div></div></div>
<div class="message assistant" id="msg-2025-12-19T22-03-17-643Z"><div class="message-header"><span class="role-label">Assistant</span><a href="#msg-2025-12-19T22-03-17-643Z" class="timestamp-link"><time datetime="2025-12-19T22:03:17.643Z" data-timestamp="2025-12-19T22:03:17.643Z">2025-12-19T22:03:17.643Z</time></a></div><div class="message-content">
<div class="assistant-text"><p>Done. I've updated <code>PRIMITIVE_GENERATION.md</code> with LLM-executable workflows. Key changes:</p>
<h2>Removed (non-existent CLI commands)</h2>
<ul>
<li><code>bio primitive new &lt;name&gt;</code></li>
<li><code>bio primitive validate &lt;name&gt;</code></li>
<li><code>bio primitive register &lt;name&gt;</code></li>
<li><code>bio primitive test &lt;name&gt;</code></li>
<li><code>bio primitive list</code></li>
</ul>
<h2>Added (actual file operations)</h2>
<table>
<thead>
<tr>
<th>Phase</th>
<th>Old (CLI)</th>
<th>New (Direct)</th>
</tr>
</thead>
<tbody>
<tr>
<td>Check exists</td>
<td><code>bio primitive list</code></td>
<td>Search <code>bioforge/src/primitive/builtins/</code></td>
</tr>
<tr>
<td>Create spec</td>
<td>touch command</td>
<td>Write TOML file directly</td>
</tr>
<tr>
<td>Validate spec</td>
<td><code>bio primitive validate</code></td>
<td>Manual checklist (types, slots, category)</td>
</tr>
<tr>
<td>Implement</td>
<td><code>bio primitive new</code></td>
<td>Create <code>.rs</code> file with template</td>
</tr>
<tr>
<td>Register</td>
<td><code>bio primitive register</code></td>
<td>Edit <code>mod.rs</code> and <code>registry.rs</code></td>
</tr>
<tr>
<td>Test</td>
<td><code>bio primitive test</code></td>
<td><code>cargo test -p bioforge &lt;name&gt;</code></td>
</tr>
</tbody>
</table>
<h2>New sections added</h2>
<ol>
<li><strong>Key Source Files to Reference</strong> - Points to existing primitives to copy patterns from:</li>
<li><code>mrpp.rs</code> for permutation tests</li>
<li><code>indicator_species.rs</code> for multi-group analysis</li>
<li><code>diversity.rs</code> for PERMANOVA pattern</li>
<li>
<p><code>context.rs</code>, <code>requirements.rs</code>, <code>category.rs</code> for API reference</p>
</li>
<li>
<p><strong>Concrete file edit instructions</strong> - Instead of "run this command", now shows exactly what to add to <code>mod.rs</code> and <code>registry.rs</code></p>
</li>
<li>
<p><strong>Complete TOML spec template</strong> - Full template with all sections (params, inputs, outputs, algorithm, provenance, llm context)</p>
</li>
</ol>
<p>The skill is now immediately actionable by an LLM without requiring any CLI tooling development.</p></div></div></div>
        

<div class="pagination">
<a href="index.html" class="index-link">Index</a>
<a href="page-011.html">&larr; Prev</a>
<a href="page-001.html">1</a>
<a href="page-002.html">2</a>
<a href="page-003.html">3</a>
<a href="page-004.html">4</a>
<a href="page-005.html">5</a>
<a href="page-006.html">6</a>
<a href="page-007.html">7</a>
<a href="page-008.html">8</a>
<a href="page-009.html">9</a>
<a href="page-010.html">10</a>
<a href="page-011.html">11</a>
<span class="current">12</span>
<a href="page-013.html">13</a>
<a href="page-014.html">14</a>
<a href="page-015.html">15</a>
<a href="page-016.html">16</a>
<a href="page-017.html">17</a>
<a href="page-018.html">18</a>
<a href="page-019.html">19</a>
<a href="page-020.html">20</a>
<a href="page-021.html">21</a>
<a href="page-022.html">22</a>
<a href="page-023.html">23</a>
<a href="page-024.html">24</a>
<a href="page-025.html">25</a>
<a href="page-026.html">26</a>
<a href="page-013.html">Next &rarr;</a>
</div>

    </div>
    <script>
document.querySelectorAll('time[data-timestamp]').forEach(function(el) {
    const timestamp = el.getAttribute('data-timestamp');
    const date = new Date(timestamp);
    const now = new Date();
    const isToday = date.toDateString() === now.toDateString();
    const timeStr = date.toLocaleTimeString(undefined, { hour: '2-digit', minute: '2-digit' });
    if (isToday) { el.textContent = timeStr; }
    else { el.textContent = date.toLocaleDateString(undefined, { month: 'short', day: 'numeric' }) + ' ' + timeStr; }
});
document.querySelectorAll('pre.json').forEach(function(el) {
    let text = el.textContent;
    text = text.replace(/"([^"]+)":/g, '<span style="color: #ce93d8">"$1"</span>:');
    text = text.replace(/: "([^"]*)"/g, ': <span style="color: #81d4fa">"$1"</span>');
    text = text.replace(/: (\d+)/g, ': <span style="color: #ffcc80">$1</span>');
    text = text.replace(/: (true|false|null)/g, ': <span style="color: #f48fb1">$1</span>');
    el.innerHTML = text;
});
document.querySelectorAll('.truncatable').forEach(function(wrapper) {
    const content = wrapper.querySelector('.truncatable-content');
    const btn = wrapper.querySelector('.expand-btn');
    if (content.scrollHeight > 250) {
        wrapper.classList.add('truncated');
        btn.addEventListener('click', function() {
            if (wrapper.classList.contains('truncated')) { wrapper.classList.remove('truncated'); wrapper.classList.add('expanded'); btn.textContent = 'Show less'; }
            else { wrapper.classList.remove('expanded'); wrapper.classList.add('truncated'); btn.textContent = 'Show more'; }
        });
    }
});
</script>
</body>
</html>